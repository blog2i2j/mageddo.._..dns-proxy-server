[
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.1/en/1-getting-started/",
	"title": "Getting Started",
	"tags": [],
	"description": "",
	"content": "Running it\n$ docker run --rm --hostname dns.mageddo \\ -v /var/run/docker.sock:/var/run/docker.sock \\ -v /etc/resolv.conf:/etc/resolv.conf \\ defreitas/dns-proxy-server Try it out\n$ ping dns.mageddo PING dns.mageddo (172.17.0.4) 56(84) bytes of data. 64 bytes from 172.17.0.4: icmp_seq=1 ttl=64 time=0.063 ms 64 bytes from 172.17.0.4: icmp_seq=2 ttl=64 time=0.074 ms 64 bytes from 172.17.0.4: icmp_seq=3 ttl=64 time=0.064 ms Click here to see more details about run DPS\n"
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.1/en/1-getting-started/running-it/",
	"title": "Running it",
	"tags": [],
	"description": "",
	"content": "Running on Linux On Docker $ docker run --rm --hostname dns.mageddo --name dns-proxy-server -p 5380:5380 \\  -v /opt/dns-proxy-server/conf:/app/conf \\  -v /var/run/docker.sock:/var/run/docker.sock \\  -v /etc/resolv.conf:/etc/resolv.conf \\  defreitas/dns-proxy-server If your system is periodically recreating /etc/resolv.conf (like dhclient does) and DPS stops working after a while you may need to try the following variant instead (see issue 166 for why this is):\n$ docker run --rm --hostname dns.mageddo --name dns-proxy-server -p 5380:5380 \\  -v /opt/dns-proxy-server/conf:/app/conf \\  -v /var/run/docker.sock:/var/run/docker.sock \\  -v /etc:/host/etc \\  -e MG_RESOLVCONF=/host/etc/resolv.conf \\  defreitas/dns-proxy-server Standalone run Download the latest version, extract and run\n$ sudo ./dns-proxy-server  Dns Proxy Server is now your current DNS server, to back everything to original state just press CTRL + C\nRunning on Windows  We have cases of people got DPS running on Windows, below the information we have of how to run DPS on these OS, if you confirm that or have some information that would be helpful to archieve this please contribute creating a pull request or issue documenting that\n  Start up DPS  docker run --name dns-proxy-server -p 5380:5380 -p 53:53/udp \\  -v /var/run/docker.sock:/var/run/docker.sock \\  defreitas/dns-proxy-server Change your default internet adapter DNS to 127.0.0.1   Press Windows + R and type ncpa.cpl then press enter or go to your network interfaces Window Change your default internet adapterDNS to 127.0.0.1 by following the below pictures (sorry they are in portuguese)  Testing the DNS server Starting some docker container and keeping it alive for DNS queries\n$ docker run --rm --hostname nginx.dev.intranet \\  -e \u0026#39;HOSTNAMES=nginx2.dev.intranet,nginx3.dev.intranet\u0026#39; nginx Solving the docker container hostname from Dns Proxy Server\n$ nslookup nginx.dev.intranet Server:\t172.22.0.6 Address:\t172.22.0.6#53 Non-authoritative answer: Name:\tdebian.dev.intranet Address: 172.22.0.7 Google keep working was well\n$ nslookup google.com Server:\t172.22.0.6 Address:\t172.22.0.6#53 Non-authoritative answer: Name:\tgoogle.com Address: 172.217.29.206 Start the server at custom port and solving from it\nnslookup -port=8980 google.com 127.0.0.1  "
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.1/en/api/v1/networks/",
	"title": "V1 Network API",
	"tags": [],
	"description": "",
	"content": "Disconnect containers from network DELETE /network/disconnect-containers HTTP/1.1 Parameters\n   Name Type Decription     netoworkId string The networkId which the containers will be disconnected from    Reponse\nHTTP/1.1 200 [ \u0026#34;success for 551adbb704bf95ae73f3f8e497560609d2016d1566196298f1787f087af4b5cd\u0026#34;, \u0026#34;success for 5f5ce51404b15069795006e7319f270db4f6d822a067e61808eeb0b2922087db\u0026#34; ] Example\n$ curl -X DELETE dns.mageddo:5380/network/disconnect-containers/?networkId=85e7564c6b71 "
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.1/en/2-features/",
	"title": "Features",
	"tags": [],
	"description": "",
	"content": "Features DNS resolution order DPS follow the below order to solve hostnames\n Try to solve the hostname from docker containers Then from local database file Then from 3rd configured remote DNS servers  "
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.1/en/2-features/gui/",
	"title": "GUI Dashboard",
	"tags": [],
	"description": "",
	"content": "Manage local DNS records Actually you can create/edit/delete A and CNAME entries using the GUI accessing http://localhost:5380 or http://dns.mageddo or by editing the config.json.\n"
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.1/en/2-features/installing-as-service/",
	"title": "Installing DPS as service",
	"tags": [],
	"description": "",
	"content": "Installing as docker service docker run --hostname dns.mageddo --name dns-proxy-server -p 5380:5380 \\  --restart=unless-stopped -d \\  -v /opt/dns-proxy-server/conf:/app/conf \\  -v /var/run/docker.sock:/var/run/docker.sock \\  -v /etc/resolv.conf:/etc/resolv.conf \\  defreitas/dns-proxy-server Installing as linux service  Download the latest release and extract it Run the service installer  $ sudo ./dns-proxy-server -service=docker Then follow the progress at the log file  $ tail -f /var/log/dns-proxy-server.log this way it will start with the OS\nif you want to stop\n$ sudo service dns-proxy-server stop Stopping serviceâ€¦ Service stopped  if you don\u0026rsquo;t want this service anymore\n$ sudo service dns-proxy-server uninstall Are you really sure you want to uninstall this service? That cannot be undone. [yes|No] yes  "
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.1/en/1-getting-started/requirements/",
	"title": "Requirements",
	"tags": [],
	"description": "",
	"content": "Requirements  Linux/Windows Docker 1.9.x (Only if you run DPS using docker or want to solve docker containers hostname using DPS)  MAC Support Based on users feedback, DPS don\u0026rsquo;t work on MAC, unfortunatly I don\u0026rsquo;t have a MAC computer to work on that, if you want to contribute please try to fix it then open a pull request, sorry for the inconvenience.\n"
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.1/en/3-configuration/",
	"title": "Configuration",
	"tags": [],
	"description": "",
	"content": "JSON configuration Version 2\n{ \u0026#34;version\u0026#34;: 2, // Remote DNS servers to be asked when can not solve from docker or local storage  // If no one server was specified then the 8.8.8.8 will be used  \u0026#34;remoteDnsServers\u0026#34;: [ \u0026#34;8.8.8.8\u0026#34;, \u0026#34;4.4.4.4:54\u0026#34; ], // all existent environments  \u0026#34;envs\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;\u0026#34;, // empty string is the default enviroment  \u0026#34;hostnames\u0026#34;: [ // all local hostnames entries  { // (optional) used to control it will be automatically generated if not passed  \u0026#34;id\u0026#34;: 1, \u0026#34;hostname\u0026#34;: \u0026#34;github.com\u0026#34;, \u0026#34;ip\u0026#34;: \u0026#34;192.168.0.1\u0026#34;, \u0026#34;ttl\u0026#34;: 255 // how many seconds cache this entry  } ] } ], \u0026#34;activeEnv\u0026#34;: \u0026#34;\u0026#34;, // the current environment keyname  \u0026#34;webServerPort\u0026#34;: 0, // web admin port, when 0 the default value is used, see --help option  \u0026#34;dnsServerPort\u0026#34;: 8980, // dns server port, when 0 the default value is used  \u0026#34;logLevel\u0026#34;: \u0026#34;DEBUG\u0026#34;, \u0026#34;logFile\u0026#34;: \u0026#34;console\u0026#34; // where the log will be written,  \u0026#34;registerContainerNames\u0026#34;: false, // if should register container name / service name as a hostname  \u0026#34;domain\u0026#34;: \u0026#34;\u0026#34;, // The container names domain  \u0026#34;dpsNetwork\u0026#34;: false, // if should create a bridge network for dps container  \u0026#34;dpsNetworkAutoConnect\u0026#34;: false // if should connect all containers to dps container } Version 1\n{ \u0026#34;remoteDnsServers\u0026#34;: [ [8,8,8,8], [4,4,4,4] ], // Remote DNS servers to be asked when can not solve from docker or local storage  // If no one server was specified then the 8.8.8.8 will be used  \u0026#34;envs\u0026#34;: [ // all existent environments  { \u0026#34;name\u0026#34;: \u0026#34;\u0026#34;, // empty string is the default  \u0026#34;hostnames\u0026#34;: [ // all local hostnames entries  { \u0026#34;id\u0026#34;: 1, \u0026#34;hostname\u0026#34;: \u0026#34;github.com\u0026#34;, \u0026#34;ip\u0026#34;: [192, 168, 0, 1], \u0026#34;ttl\u0026#34;: 255 } ] } ], \u0026#34;activeEnv\u0026#34;: \u0026#34;\u0026#34;, // the default env keyname  \u0026#34;lastId\u0026#34;: 1, // hostnames sequence, don\u0026#39;t touch here  \u0026#34;webServerPort\u0026#34;: 0, // web admin port, when 0 the default value is used, see --help option  \u0026#34;dnsServerPort\u0026#34;: 8980, // dns server port, when 0 the default value is used  \u0026#34;logLevel\u0026#34;: \u0026#34;DEBUG\u0026#34;, \u0026#34;logFile\u0026#34;: \u0026#34;console\u0026#34; // where the log will be written,  \u0026#34;registerContainerNames\u0026#34;: false // if should register container name / service name as a hostname } Environment variable configuration    VARIBLE DESCRIPTION DEFAULT VALUE     MG_RESOLVCONF Linux resolvconf path to set DPS as default DNS /etc/resolv.conf   MG_LOG_LEVEL  INFO   MG_LOG_FILE Path where to logs will be stored console   MG_REGISTER_CONTAINER_NAMES if should register container name / service name as a hostname false   MG_HOST_MACHINE_HOSTNAME hostname to solve host machine IP host.docker   MG_DOMAIN The container names domain (requires MG_REGISTER_CONTINER_NAMES=TRUE) .docker    Terminal configuration  -compress compress replies -conf-path string The config file path (default \u0026quot;conf/config.json\u0026quot;) -cpuprofile string write cpu profile to file -default-dns This DNS server will be the default server for this machine (default true) -domain string Domain utilized to solver containers and services hostnames (default \u0026quot;docker\u0026quot;) -dps-network Create a bridge network for DPS increasing compatibility -dps-network-auto-connect Connect all running and new containers to the DPS network, this way you will probably not have resolution issues by acl (implies dps-network=true) -help This message -host-machine-hostname string The hostname to get host machine IP (default \u0026quot;host.docker\u0026quot;) -log-file string Log to file instead of console, (true=log to default log file, /tmp/log.log=log to custom log location) (default \u0026quot;console\u0026quot;) -log-level string Log Level ERROR, WARNING, INFO, DEBUG (default \u0026quot;INFO\u0026quot;) -register-container-names If must register container name / service name as host in DNS server -server-port int The DNS server to start into (default 53) -service string Setup as service, starting with machine at boot docker = start as docker service, normal = start as normal service, uninstall = uninstall the service from machine -service-publish-web-port Publish web port when running as service in docker mode (default true) -tsig string use MD5 hmac tsig: keyname:base64 -version Current version -web-server-port int The web server port (default 5380) "
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.1/en/2-features/solving-hostnames-wildcard/",
	"title": "Solving hostnames using wildcards",
	"tags": [],
	"description": "",
	"content": "If you register a hostname with . at start, then all subdomains will solve to that container/local storage entry\nExample\ndocker run --rm --hostname .mageddo.com nginx:latest  Now all mageddo.com subdomains will solve to that nginx container\n$ nslookup site1.mageddo.com Server:\t172.17.0.4 Address:\t172.17.0.4#53 Non-authoritative answer: Name:\tsite1.mageddo.com Address: 172.17.0.5 $ nslookup mageddo.com Server:\t172.17.0.4 Address:\t172.17.0.4#53 Non-authoritative answer: Name:\tmageddo.com Address: 172.17.0.5 "
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.1/en/4-compiling/",
	"title": "Compiling from source",
	"tags": [],
	"description": "",
	"content": "Building from source with docker DPS uses docker to simplify the compile process\nGenerate the binaries\n$ docker-compose rm -f \u0026amp;\u0026amp; docker-compose up --build prod-build-binary-dps Starting docker-dns-server-compiler Attaching to docker-dns-server-compiler docker-dns-server-compiler | ok github.com/mageddo/dns-proxy-server/conf\t0.008s docker-dns-server-compiler | ? github.com/mageddo/dns-proxy-server/controller\t[no test files] ... docker-dns-server-compiler | github.com/mageddo/dns-proxy-server/flags ... docker-dns-server-compiler | _/app/src docker-dns-server-compiler exited with code 0 Then binaries mus be available at build folder\n$ ls build/ dns-proxy-server dns-proxy-server-2.5.1.tgz static If you want you can build the docker image\n$ docker-compose build prod-build-image-dps \u0026amp;\u0026amp; docker-compose up prod-dps Take a look at docker-compose.yml for prod-build-image-dps* to build other arch\nBuilding binary for specific ARCH You can generate DPS binaries for all archs that are supported by golang, DPS were designed to run on linux though.\n$ docker-compose run prod-build-binary-dps builder.bash build linux amd64 \u0026gt; Testing \u0026gt; Tests completed \u0026gt; Building... \u0026gt; Compiling os=linux, arch=amd64 Used technologies  Docker Docker Compose Golang  "
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.1/en/2-features/logs/",
	"title": "Configuring logs",
	"tags": [],
	"description": "",
	"content": "Configuring log output You can disable, log to console, log to default log file path or specify a log path at config file, environment or command line argument. Available options:\n console (default) - log to console false - Logs are disabled true - stop log to console and log to /var/log/dns-proxy-server.log file eg. /tmp/log.log - log to specified path  Config File\n{ ... \u0026#34;logFile\u0026#34;: \u0026#34;console\u0026#34; ... } Environment\nexport MG_LOG_FILE=console  Command line argument\ngo run dns.go -log-file=console  Configuring log level You can change system log level using environment variable, config file, or command line argument, DPS will consider the parameters in that order, first is more important.\nAvailable levels:\n ERROR WARNING INFO DEBUG (Default)  Environment\nexport MG_LOG_LEVEL=DEBUG  Config file\n{ ... \u0026#34;logLevel\u0026#34;: \u0026#34;DEBUG\u0026#34; ... } Command line argument\ngo run dns.go -log-level=DEBUG  "
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.1/en/5-developing/",
	"title": "Developing at the project",
	"tags": [],
	"description": "",
	"content": "Vanilla Developing Backend\n$ ./gradlew quarkusDev Front end app (optional)\n$ cd app \u0026amp;\u0026amp; npm start Developing with docker $ docker-compose rm -f \u0026amp;\u0026amp; docker-compose up --build app-dps compiler-dps  Running the application\n$ docker-compose exec compiler-dps bash $ go run dns.go Running the GUI\n$ docker-compose exec app-dps sh $ npm start Running unit tests\n$ go test -cover=false ./.../  "
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.1/en/6-generating-docs/",
	"title": "Generating the docs",
	"tags": [],
	"description": "",
	"content": "Live docs preview To se the current docs just type\nhugo server --source docs  Generating doc statics DPS uses Hugo to generate static docs. To generate the HTML use the following\n$ ./builder.bash docs "
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.1/en/2-features/solving-host-machine-ip/",
	"title": "Solve host machine IP from anywhere",
	"tags": [],
	"description": "",
	"content": "Just use host.docker\n$ ping host.docker PING host.docker (172.21.0.1) 56(84) bytes of data. 64 bytes from 172.21.0.1 (172.21.0.1): icmp_seq=1 ttl=64 time=0.086 ms 64 bytes from 172.21.0.1 (172.21.0.1): icmp_seq=2 ttl=64 time=0.076 ms 64 bytes from 172.21.0.1 (172.21.0.1): icmp_seq=3 ttl=64 time=0.081 ms You can customize this hostname by setting\nEnvironment variable\n$ docker run dns-proxy-server -e MG_HOST_MACHINE_HOSTNAME=$(cat /etc/hostname) Command line option\n$ ./dns-proxy-server --host-machine-hostname $(cat /etc/hostname) Json configuration\n{ \u0026#34;hostMachineHostname\u0026#34;: \u0026#34;host.docker\u0026#34; } Notes:\nBe aware if you set the host machine hostname as the machine name then you will have to remove its name from /etc/hosts since OS try to resolve names from hosts file first then from DNS server\n"
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.1/en/2-features/accessing-container-by-name/",
	"title": "Access container by its container name / service name",
	"tags": [],
	"description": "",
	"content": "$ docker run --rm --name my-nginx nginx $ nslookup my-nginx.docker Server:\t172.17.0.3 Address:\t172.17.0.3#53 Non-authoritative answer: Name:\tmy-nginx.docker Address: 10.0.2.3 You can enable this feature by\nActivating by command line\n./dns-proxy-server -register-container-names  Configuring at json config file\n... \u0026quot;registerContainerNames\u0026quot;: true ... Using environment variable\nMG_REGISTER_CONTAINER_NAMES=1 ./dns-proxy-server You can also customize the domain from docker to whatever you want by\nActivating by command line\n./dns-proxy-server --domain docker  Configuring at json config file\n... \u0026quot;domain\u0026quot;: \u0026quot;docker\u0026quot; ... Using environment variable\nMG_DOMAIN=docker ./dns-proxy-server "
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.1/en/api/",
	"title": "API",
	"tags": [],
	"description": "",
	"content": "APIs "
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.1/en/2-features/specify-from-which-network-solve-container/",
	"title": "Specify from which network solve container IP",
	"tags": [],
	"description": "",
	"content": "If your container have multiple networks then you can specify which network to use when solving IP by specifying dps.network label.\nCreating a container with two networks attached to\n$ docker network create --attachable network1 $ docker network create --attachable network2 $ docker run --name nginx1 --rm --label dps.network=network2 --hostname server1.acme.com --network network1 nginx $ docker network connect network2 nginx1 Getting networks masks\n$ docker network inspect -f \u0026#34;{{ .IPAM.Config }}\u0026#34; network1 [{172.31.0.0/16 172.31.0.1 map[]}] $ docker network inspect -f \u0026#34;{{ .IPAM.Config }}\u0026#34; network2 [{192.168.16.0/20 192.168.16.1 map[]}] Solving container IP checking that solved IP will be the respective to configured dps.network label\n$ nslookup server1.acme.com Server:\t172.17.0.3 Address:\t172.17.0.3#53 Non-authoritative answer: Name:\tserver1.acme.com Address: 192.168.16.2 "
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.1/en/versions/",
	"title": "Versions",
	"tags": [],
	"description": "",
	"content": " latest 3.1 3.1 3.0 2.19 2.18 2.15 2.14 2.13  "
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.1/en/2-features/dps-network-resolution/",
	"title": "DPS docker network",
	"tags": [],
	"description": "",
	"content": "At previous versions DPS had a caveat where you only would be able to access other docker containers, access host or be accessed if they were at a bridge network, DPS inclusively, this bridge network also had to be the first defined on container networks to have sure DPS would solve to its IP, since 2.15.0 DPS can do this job for you.\nIt is a really helpful behavior when you are in development but maybe a security issue when you are in production, this way you can enable or disable this feature if you want.\nActivating by command line\n./dns-proxy-server --dps-network-auto-connect  Configuring at json config file\n... \u0026quot;dpsNetworkAutoConnect\u0026quot;: true ... Using environment variable\nMG_DPS_NETWORK_AUTO_CONNECT=1 ./dns-proxy-server  OBS: even if this feature is disabled a fix was made and now DPS gives priority to solve bridge networks over the others (if a bridge network were found for the container)\n Simulating the issue We can simulate the issue by the following example:\nYou have a container running on a overlay network, it means the container can not be accessed by the host or by containers which are not on its network\ndocker-compose.yml\nversion: \u0026#39;3\u0026#39; services: nginx-1: image: nginx container_name: nginx-1 hostname: nginx-1.app networks: - nginx-network networks: nginx-network: driver: overlay starting up the container and testing\n$ docker-compose up $ curl --connect-timeout 2 nginx-1.app curl: (7) Failed to connect to nginx-1.app port 80: Connection timed out The solution for this is to specify a bridge network on the docker-compose.yml and also specify that you wanna solve the ip of the bridge network instead of the overlay one\ndocker-compose.yml\nversion: \u0026#39;3\u0026#39; services: nginx-1: image: nginx container_name: nginx-1 hostname: nginx-1.app networks: - nginx-network - nginx-network-bridge labels: dps.network: tmp_nginx-network-bridge networks: nginx-network: driver: overlay nginx-network-bridge: driver: bridge $ docker-compose up $ curl -I --connect-timeout 2 nginx-3.app HTTP/1.1 200 OK So since 2.15.0 DPS can do all of this for you just by creating a bridge network and making sure all containers are connected to it, this way you will not have issues to access a container from another, the host from a container or vice versa.\n"
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.1/en/2-features/multiple-environments/",
	"title": "Multiple Environments",
	"tags": [],
	"description": "",
	"content": "As DPS 2.18 you can group your hostnames by environments, this is a very useful feature when you wanna solve the same hostname to different IPs depending of what you\u0026rsquo;re doing, e.g developing in your machine or testing the QA environment as the example below:\nLet\u0026rsquo;s say you\u0026rsquo;re developing at the acme.com so you wanna to solve it to your local machine, then you can configure DPS local entries as the following\nWhen you are done with your work and deployed to the QA environment and wanna test it, let\u0026rsquo;s say your app is deployed at the QA machine addressed by the IP 192.168.0.50, so you can create a new env on DPS e.g. QA and create the acme.com A record pointing to the 192.168.0.50 address.\nThis way you can swap between local and qa environments in a fast and convenient aproach\n"
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.1/en/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.1/en/credits/",
	"title": "Credits",
	"tags": [],
	"description": "",
	"content": "Contributors Thanks to them for making Open Source Software a better place !\n"
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.1/en/",
	"title": "Getting Started",
	"tags": [],
	"description": "",
	"content": "Main features DPS is a end user(developers, Server Administrators) DNS server tool to develop systems with docker solving docker containers hostnames:\n Solve hostnames from local configuration database Solve hostnames from docker containers using docker hostname option or HOSTNAMES env Solve hostnames from a list of configured DNS servers(as a proxy) if no answer of two above Solve hostnames using wildcards Graphic interface to Create/List/Update/Delete A/CNAME records Solve host machine IP using host.docker hostname Access container by itâ€™s container name / service name Specify from which network solve container IP  "
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.1/en/showcase/",
	"title": "Showcase",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.1/en/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]