[
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.12/en/2-features/auto-configuration-as-default-dns/",
	"title": "Auto configure host default DNS",
	"tags": [],
	"description": "",
	"content": " DPS will configure itself as the default machine DNS when running on standalone mode (not on docker).\nActivation This feature is active by default and can be disabled by defaultDns json config or -default-dns commandline arg.\nPlatform Support Check the following table to understand the support at every platform:\n✅: Fully supported, ❌: Not supported, ⚠️: Partially supported\n   Platform Support Description     Linux ✅ Will use system-resolved when avaible or /etc/resolv.conf, check MG_RESOLVCONF env check which file will be configured, see running on Linux for more details   MAC OSX ✅ DPS will use networksetup to configure the DNS, check running on MAC to see more details   Windows ✅ Will configure available network interfaces to query DPS as the default DNS, you can see available networks by running ncpa.cpl    Docker Limitations When you run DPS on docker it won\u0026rsquo;t be able to configure itself as the default host DNS depending on your environment, so you will need to that manually, see specific running it instructions for your platform for more details.\n"
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.12/en/1-getting-started/",
	"title": "Getting Started",
	"tags": [],
	"description": "",
	"content": "Redirecting to running it page \u0026hellip;\n"
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.12/en/1-getting-started/running-it/linux/",
	"title": "Linux running instructions",
	"tags": [],
	"description": "",
	"content": " Running on Linux Running as Docker Service If you are using docker on your machine that\u0026rsquo;s the best choice as it will automatically start DPS on every boot:\n$ docker run --hostname dns.mageddo --restart=unless-stopped -d \\ --network host \\ -v /var/run/docker.sock:/var/run/docker.sock \\ -v /etc/systemd/:/host/etc/systemd \\ -v /etc/:/host/etc \\ defreitas/dns-proxy-server  It will configure DPS as default DNS on systemd-resolved or vanilla resolv.conf depending on your system. If you\u0026rsquo;re using system-resolved then run command below to restart its service and make DPS as default DNS changes to take effect.\n$ service systemd-resolved restart  Click here to see usage samples\nExplaining the running params:\n--network host: Running on host mode make it possible to DPS bind the DNS server port to the host network interface, this way all containers will have access to DPS address and use DPS features. If you don\u0026rsquo;t want to use that option then you can consider use DPS Network feature.\n/var/run/docker.sock: Docker socket, so DPS can query the running containers and solve their IP when asked.\n/etc/systemd/:/host/etc/systemd / /etc/:/host/etc: Depending on your distro you may are using system-resolved or vanila resolv.conf to configure available DNS Servers, DPS will look at both and choose the best to be configured.\nStandalone run Download the latest release, extract and run:\n$ sudo ./dns-proxy-server  Now DNS Proxy Server is your DNS server, to back everything to original state just press CTRL + C;\nClick here to see usage samples\n"
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.12/en/1-getting-started/running-it/mac/",
	"title": "MacOSX running instructions",
	"tags": [],
	"description": "",
	"content": " Running on MAC DPS actually is fully supported on MAC knowing docker limitation features.\nRunning as Docker as service Running DPS as docker service\n$ docker run -d -p 5380:5380 -p 53:53/udp -p 53:53/tcp --restart=unless-stopped \\ -v /var/run/docker.sock:/var/run/docker.sock \\ defreitas/dns-proxy-server   Go to configuring DPS as default DNS to complete DPS configuration. Check this for usage samples.  Standalone run Download the latest release (I recomend the jar one), extract and run:\n$ sudo java -jar ./dns-proxy-server  Check this for usage samples.\nWhen running on standalone mode (not on docker container) DPS will be able to auto configure itself as OSX default DNS, after 5 seconds you see something like usingDnsConfigurator=DnsConfiguratorOSx at the logs.\nConfiguring DPS as default DNS manually When not running in standalone mode you will need to configure DPS as default DPS manually, check the instructions below:\nTo list available networks:\n$ networksetup -listallnetworkservices An asterisk (*) denotes that a network service is disabled. USB 10/100/1000 LAN Wi-Fi Thunderbolt Bridge  In my case the right Network is Wi-Fi, before change anything let\u0026rsquo;s check if it has some manual configured DNS server:\n$ networksetup -getdnsservers Wi-Fi There aren't any DNS Servers set on Wi-Fi.  If it returns some server IP then is a good idea to backup it then you can restore the configurations later.\nLet\u0026rsquo;s set DPS as the default DNS Server, best option here is to get your network IP address, Wi-Fi in my case which has 192.168.0.14 set, 127.0.0.1 will partially works because this way containers won\u0026rsquo;t be able to solve each other, just the host solve the containers.\nObs: Be aware you need to run DPS in port 53 as MAC doesn\u0026rsquo;t accept custom port especification.\n$ networksetup -setdnsservers Wi-Fi 192.168.0.14  If you need to remove the configured DNS server then it will use your network provider DNS\n$ networksetup -setdnsservers Wi-Fi Empty  See this thread with more use cases.\n"
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.12/en/1-getting-started/running-it/",
	"title": "Running it",
	"tags": [],
	"description": "",
	"content": " Specific Instructions  Linux running instructions   MacOSX running instructions   Windows running instructions   Running as Service If you are using Docker on your machine I recommend to run DPS as a docker service, this way it will automatically be configured whenever you restart the machine, checkout the instructions for Linux, Mac and Windows\nGeneral Instructions The process to running DPS is basically the same for all platforms:\nDownload the latest release for your platform, if no binary available use the jar (requires JRE 19+)\nStart DPS (you need to run as administrator/sudo so DPS can set itself as the default DNS)\nsudo ./dns-proxy-server  Then you can solve from pre-configured entries (conf/config.json):\n$ ping dps-sample.dev PING dps-sample.dev (192.168.0.254) 56(84) bytes of data.  Also solve Docker containers*:\n$ docker run --rm --hostname nginx.dev nginx $ ping nginx.dev PING nginx.dev (172.17.0.4) 56(84) bytes of data. 64 bytes from 172.17.0.4 (172.17.0.4): icmp_seq=1 ttl=64 time=0.043 ms 64 bytes from 172.17.0.4 (172.17.0.4): icmp_seq=2 ttl=64 time=0.022 ms  *Not supported on Windows\nRunning on Docker You probably want to check on specific running instructions to configure all DPS features when running on docker, set as default DNS and docker container solving have different docker run options for each platform.\nDespite on this, the standalone way to run DPS on docker can be done by following:\n$ docker run --rm --hostname dns.mageddo -p 5380:5380 -p 53:53/udp defreitas/dns-proxy-server  If you get something like 0.0.0.0:53: bind: address already in use then probably there is some other DNS server like systemd-resolved, so you can try to bind DPS to a specific network interface like 127.0.0.1 or 192.168.x.x, check your local interfaces for the best fit.\n$ docker run --rm --hostname dns.mageddo -p 5380:5380 -p 127.0.0.1:53:53/udp defreitas/dns-proxy-server  Runining on docker limitations:\n You have to configure docker as default DNS by yourself, check specific instructions, to see how to do that you can check more details here for the reason.  "
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.12/en/api/v1/networks/",
	"title": "V1 Network API",
	"tags": [],
	"description": "",
	"content": " Disconnect containers from network DELETE /network/disconnect-containers HTTP/1.1  Parameters\n   Name Type Decription     netoworkId string The networkId which the containers will be disconnected from    Reponse\nHTTP/1.1 200 [ \u0026quot;success for 551adbb704bf95ae73f3f8e497560609d2016d1566196298f1787f087af4b5cd\u0026quot;, \u0026quot;success for 5f5ce51404b15069795006e7319f270db4f6d822a067e61808eeb0b2922087db\u0026quot; ]  Example\n$ curl -X DELETE dns.mageddo:5380/network/disconnect-containers/?networkId=85e7564c6b71  "
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.12/en/1-getting-started/running-it/windows/",
	"title": "Windows running instructions",
	"tags": [],
	"description": "",
	"content": " Running on Windows You can run DPS on Windows host without any issues except by DPS isn\u0026rsquo;t capable yet to connect to docker API and solve containers (see backlog issue).\nRunning as Docker Service 1- If you are using docker on your machine that\u0026rsquo;s the best choice as it will automatically start DPS on every boot:\n$ docker run -d --restart=unless-stopped -p 53:53/udp -p 53:53/tcp -p 5380:5380 defreitas/dns-proxy-server  2- Set DPS as the default DNS on Windows, check the instructions below on (Configure DPS as default DNS on Windows) or click here\n3- Now you are able to solve containers form local configuration, also network addresses keep solving as well\n\u0026gt; nslookup dps-sample.dev Server: UnKnown Address: 127.0.0.1 Non-authoritative answer: Name: dps-sample.dev Addresses: 192.168.0.254 192.168.0.254 \u0026gt; nslookup acme.com Server: UnKnown Address: 127.0.0.1 Non-authoritative answer: Name: acme.com Address: 23.93.76.124  You can access the GUI by the address http://localhost:5380/ , see GUI Dashboard feature\nStandalone Run  Download the latest release for Windows Run dps by dns-proxy-server.exe  If you run DPS as administrator (using administrator prompt) then it will capable of configure itself as the default DNS or check instructions below of how to set DPS as default DNS manually.\nConfigure DPS as default DNS on Windows 1. Find the host network ip v4 address\nYou can also use 127.0.0.1 or if don\u0026rsquo;t work your you try the following. On prompt command run ipconfig and get one of the ipv4 addresses, it\u0026rsquo;s recommended to get the IP from the real network card, 192.168.0.128 in my case.\n\u0026gt; ipconfig Windows IP Configuration Ethernet adapter Ethernet: Connection-specific DNS Suffix . : spo.virtua.com.br IPv4 Address. . . . . . . . . . . : 192.168.0.128 Subnet Mask . . . . . . . . . . . : 255.255.255.0 Default Gateway . . . . . . . . . : 192.168.0.1  2. Change your default internet adapter DNS to IP got on the last step\n Press Windows + R and type ncpa.cpl then press enter or go to your network interfaces Window Change your default internet adapter DNS to ip you get the last step 127.0.0.1 or 192.168.0.128 in my case by following the pictures below  Uncheck IPV6 because Windows can try to solve hostnames by using a IPV6 DNS server, then requests won\u0026rsquo;t be sent to DPS, actually DPS doesn\u0026rsquo;t support IPV6.\n"
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.12/en/2-features/",
	"title": "Features",
	"tags": [],
	"description": "",
	"content": " Features  Auto configure host default DNS   GUI Dashboard   Installing DPS as service   Different Docker Networks Solving   Wildcards hostnames Solving   Configuring logs   Solve host machine IP from anywhere   Access container by its container name / service name   Specify from which network solve container IP   DPS docker network   Multiple Environments   Main features use cases Solving container hostname\n$ nslookup dns.mageddo Server: 127.0.0.53 Address: 127.0.0.53#53 Non-authoritative answer: Name: dns.mageddo Address: 172.157.5.1  Solving host machine IP\n$ nslookup host.docker Server: 127.0.0.53 Address: 127.0.0.53#53 Non-authoritative answer: Name: host.docker Address: 172.157.5.1  Solving from Internet\n$ nslookup acme.com Server: 127.0.0.53 Address: 127.0.0.53#53 Non-authoritative answer: Name: acme.com Address: 23.93.76.124  Solving from local database\n$ nslookup dps-sample.dev Server: 127.0.0.53 Address: 127.0.0.53#53 Non-authoritative answer: Name: dps-sample.dev Address: 192.168.0.254  Access the gui by using http://localhost:5380 , see this link.\nDNS resolution order DPS follow the below order to solve hostnames\n Try to solve the hostname from docker containers Then from local database file Then from 3rd configured remote DNS servers  "
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.12/en/2-features/gui/",
	"title": "GUI Dashboard",
	"tags": [],
	"description": "",
	"content": " Manage local DNS records Actually you can create/edit/delete A and CNAME entries using the GUI accessing http://localhost:5380 or http://dns.mageddo or by editing the config.json.\n"
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.12/en/2-features/installing-as-service/",
	"title": "Installing DPS as service",
	"tags": [],
	"description": "",
	"content": " Installing as docker service docker run --hostname dns.mageddo --name dns-proxy-server -p 5380:5380 \\ --restart=unless-stopped -d \\ -v /opt/dns-proxy-server/conf:/app/conf \\ -v /var/run/docker.sock:/var/run/docker.sock \\ -v /etc/resolv.conf:/etc/resolv.conf \\ defreitas/dns-proxy-server  Installing as linux service  Download the latest release and extract it Run the service installer  $ sudo ./dns-proxy-server -service=docker   Then follow the progress at the log file  $ tail -f /var/log/dns-proxy-server.log   this way it will start with the OS\nif you want to stop\n$ sudo service dns-proxy-server stop Stopping service… Service stopped  if you don\u0026rsquo;t want this service anymore\n$ sudo service dns-proxy-server uninstall Are you really sure you want to uninstall this service? That cannot be undone. [yes|No] yes  "
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.12/en/1-getting-started/requirements/",
	"title": "Requirements",
	"tags": [],
	"description": "",
	"content": " Requirements  Linux/Windows Docker 1.9.x (Only if you run DPS using docker or want to solve docker containers hostname using DPS)  MAC Support Based on users feedback, DPS don\u0026rsquo;t work on MAC, unfortunatly I don\u0026rsquo;t have a MAC computer to work on that, if you want to contribute please try to fix it then open a pull request, sorry for the inconvenience.\n"
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.12/en/3-configuration/",
	"title": "Configuration",
	"tags": [],
	"description": "",
	"content": " JSON configuration Version 2\n{ \u0026quot;version\u0026quot;: 2, // Remote DNS servers to be asked when can not solve from docker or local storage // If no one server was specified then the 8.8.8.8 will be used \u0026quot;remoteDnsServers\u0026quot;: [ \u0026quot;8.8.8.8\u0026quot;, \u0026quot;4.4.4.4:54\u0026quot; ], // all existent environments \u0026quot;envs\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;\u0026quot;, // empty string is the default enviroment \u0026quot;hostnames\u0026quot;: [ // all local hostnames entries { // (optional) used to control it will be automatically generated if not passed \u0026quot;id\u0026quot;: 1, \u0026quot;hostname\u0026quot;: \u0026quot;github.com\u0026quot;, \u0026quot;ip\u0026quot;: \u0026quot;192.168.0.1\u0026quot;, \u0026quot;ttl\u0026quot;: 255 // how many seconds cache this entry } ] } ], \u0026quot;activeEnv\u0026quot;: \u0026quot;\u0026quot;, // the current environment keyname \u0026quot;webServerPort\u0026quot;: 0, // web admin port, when 0 the default value is used, see --help option \u0026quot;dnsServerPort\u0026quot;: 8980, // dns server port, when 0 the default value is used \u0026quot;logLevel\u0026quot;: \u0026quot;DEBUG\u0026quot;, \u0026quot;logFile\u0026quot;: \u0026quot;console\u0026quot; // where the log will be written, \u0026quot;registerContainerNames\u0026quot;: false, // if should register container name / service name as a hostname \u0026quot;domain\u0026quot;: \u0026quot;\u0026quot;, // The container names domain \u0026quot;dpsNetwork\u0026quot;: false, // if should create a bridge network for dps container \u0026quot;dpsNetworkAutoConnect\u0026quot;: false // if should connect all containers to dps container }  Version 1\n{ \u0026quot;remoteDnsServers\u0026quot;: [ [8,8,8,8], [4,4,4,4] ], // Remote DNS servers to be asked when can not solve from docker or local storage // If no one server was specified then the 8.8.8.8 will be used \u0026quot;envs\u0026quot;: [ // all existent environments { \u0026quot;name\u0026quot;: \u0026quot;\u0026quot;, // empty string is the default \u0026quot;hostnames\u0026quot;: [ // all local hostnames entries { \u0026quot;id\u0026quot;: 1, \u0026quot;hostname\u0026quot;: \u0026quot;github.com\u0026quot;, \u0026quot;ip\u0026quot;: [192, 168, 0, 1], \u0026quot;ttl\u0026quot;: 255 } ] } ], \u0026quot;activeEnv\u0026quot;: \u0026quot;\u0026quot;, // the default env keyname \u0026quot;lastId\u0026quot;: 1, // hostnames sequence, don't touch here \u0026quot;webServerPort\u0026quot;: 0, // web admin port, when 0 the default value is used, see --help option \u0026quot;dnsServerPort\u0026quot;: 8980, // dns server port, when 0 the default value is used \u0026quot;logLevel\u0026quot;: \u0026quot;DEBUG\u0026quot;, \u0026quot;logFile\u0026quot;: \u0026quot;console\u0026quot; // where the log will be written, \u0026quot;registerContainerNames\u0026quot;: false // if should register container name / service name as a hostname }  Environment variable configuration Boolean values\n You can use 1 or true (case insensitive) to specify which the flag is activated, any other value will be considered false.\n    VARIBLE DESCRIPTION DEFAULT VALUE     MG_RESOLVCONF Linux resolvconf or systemd-resolved path to set DPS as default DNS /host/etc/systemd/resolved.conf,/host/etc/resolv.conf,/etc/systemd/resolved.conf,/etc/resolv.conf   MG_LOG_LEVEL  INFO   MG_LOG_FILE Path where to logs will be stored console   MG_REGISTER_CONTAINER_NAMES if should register container name / service name as a hostname false   MG_HOST_MACHINE_HOSTNAME hostname to solve host machine IP host.docker   MG_DOMAIN The container names domain (requires MG_REGISTER_CONTINER_NAMES=TRUE) .docker    Terminal configuration Usage: \u0026lt;main class\u0026gt; [-default-dns] [-dps-network] [-dps-network-auto-connect] [-help] [-register-container-names] [-service-publish-web-port] [-version] [-conf-path=\u0026lt;configPath\u0026gt;] [-domain=\u0026lt;domain\u0026gt;] [-host-machine-hostname=\u0026lt;hostMachineHostname\u0026gt;] [-log-file=\u0026lt;logToFile\u0026gt;] [-log-level=\u0026lt;logLevel\u0026gt;] [-server-port=\u0026lt;dnsServerPort\u0026gt;] [-service=\u0026lt;service\u0026gt;] [-web-server-port=\u0026lt;webServerPort\u0026gt;] -conf-path, --conf-path=\u0026lt;configPath\u0026gt; The config file path (default conf/config.json) -default-dns, --default-dns This DNS server will be the default server for this machine (default true) -domain, --domain=\u0026lt;domain\u0026gt; Domain utilized to solver containers and services hostnames (default docker) -dps-network, --dps-network Create a bridge network for DPS increasing compatibility (default false) -dps-network-auto-connect, --dps-network-auto-connect Connect all running and new containers to the DPS network, this way you will probably not have resolution issues by acl (implies dps-network=true) (default false) -help, --help This message (default false) -host-machine-hostname, --host-machine-hostname=\u0026lt;hostMachineHostname\u0026gt; The hostname to get host machine IP (default host.docker) -log-file, --log-file=\u0026lt;logToFile\u0026gt; Log to file instead of console, (true=log to default log file, /tmp/log.log=log to custom log location) (default console) -log-level, --log-level=\u0026lt;logLevel\u0026gt; Log Level ERROR, WARNING, INFO, DEBUG (default INFO) -register-container-names, --register-container-names If must register container name / service name as host in DNS server (default false) -server-port, --server-port=\u0026lt;dnsServerPort\u0026gt; The DNS server to start into (default 53) -service, --service=\u0026lt;service\u0026gt; Setup as service, starting with machine at boot docker = start as docker service, normal = start as normal service, uninstall = uninstall the service from machine (default \u0026lt;empty\u0026gt;) -service-publish-web-port, --service-publish-web-port Publish web port when running as service in docker mode (default true) -version, --version Shows the current version (default false) -web-server-port, --web-server-port=\u0026lt;webServerPort\u0026gt; The web server port (default 5380)  "
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.12/en/2-features/docker-different-networks-solving/",
	"title": "Different Docker Networks Solving",
	"tags": [],
	"description": "",
	"content": "DPS can lead with docker containers with different networks, it will find the target container best matching IP, best matching means the IP which have the most chances of be accessible from the client, no distinction if the client is another container or not.\nYou can click here to see a pratical working sample.\nThe following table describles the possible scenarios involving docker container networks, this is an automatic decision made by DPS, if you want to enforce some network resolution you can use dps.network label .\n   DPS Container Network Client Container Network Target Container Network Result Description     any:bridge any:bridge any:bridge OK Everything works fine when all the networks are using bridge driver, no problem if the networks are different   Network x Network x Network x OK Even with restrictive networks (like overlay driver) the resolution will work, since all containers are connected to this same network.   Network a, Network b Network a Network b OK The minimal requirement is that client must be on the same network which DPS so the client will able to query DPS, then client also need to be on the same network which the target container, so it will be able to ping after solve the hostname, DPS don\u0026rsquo;t really need to be able to talk with the target container since it won\u0026rsquo;t turn into a client a some moment    "
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.12/en/2-features/solving-hostnames-wildcard/",
	"title": "Wildcards hostnames Solving",
	"tags": [],
	"description": "",
	"content": "If you register a hostname with . at start, then all subdomains will solve to that container/local storage entry\nExample\ndocker run --rm --hostname .mageddo.com nginx:latest  Now all mageddo.com subdomains will solve to that nginx container\n$ nslookup site1.mageddo.com Server:\t172.17.0.4 Address:\t172.17.0.4#53 Non-authoritative answer: Name:\tsite1.mageddo.com Address: 172.17.0.5 $ nslookup mageddo.com Server:\t172.17.0.4 Address:\t172.17.0.4#53 Non-authoritative answer: Name:\tmageddo.com Address: 172.17.0.5  "
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.12/en/4-developing/compiling/",
	"title": "Compiling from source",
	"tags": [],
	"description": "",
	"content": " Requirements  JDK 17+  Building from source Build the frontend files (optional)\n./builder.bash build-frontend  Build and run the program\n$ ./gradlew build compTest -Dquarkus.package.type=uber-jar \u0026amp;\u0026amp; java -jar ./build/dns-proxy-server.jar  "
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.12/en/5-tutorials/",
	"title": "Tutorials",
	"tags": [],
	"description": "",
	"content": " Tutorials  Configuring a Service Discovery solution on Docker using DNS Proxy Server and NGINX   3rd Tutorials  \u0026lt;Open a Pull Request and link a DPS tutorial here\u0026gt;  "
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.12/en/2-features/logs/",
	"title": "Configuring logs",
	"tags": [],
	"description": "",
	"content": " Configuring log output You can disable, log to console, log to default log file path or specify a log path at config file, environment or command line argument. Available options:\n console (default) - log to console false - Logs are disabled true - stop log to console and log to /var/log/dns-proxy-server.log file  eg. /tmp/log.log - log to specified path  Config File\n{ ... \u0026quot;logFile\u0026quot;: \u0026quot;console\u0026quot; ... }  Environment\nexport MG_LOG_FILE=console  Command line argument\n./dns-proxy-server -log-file=console  Configuring log level You can change system log level using environment variable, config file, or command line argument, DPS will consider the parameters in that order, first is more important.\nAvailable levels:\n ERROR WARNING INFO (Default) DEBUG  Environment\nexport MG_LOG_LEVEL=DEBUG  Config file\n{ ... \u0026quot;logLevel\u0026quot;: \u0026quot;DEBUG\u0026quot; ... }  Command line argument\n./dns-proxy-server -log-level=DEBUG  "
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.12/en/4-developing/",
	"title": "Developing",
	"tags": [],
	"description": "",
	"content": " Vanilla Developing Backend\n$ ./gradlew quarkusDev  Make your DNS queries to IP and TCP/UDP ports indicated at the console log.\nFront end app (optional)\n$ cd app \u0026amp;\u0026amp; npm start  Then access http://localhost:3000/ , front end will proxy to http://localhost:5380 backend.\nWith Docker $ ./gradlew build -Dquarkus.package.type=uber-jar -i -x check $ docker-compose -f docker-compose-dev.yml up  or\n$ ./gradlew build -Dquarkus.package.type=uber-jar -i -x check $ docker-compose -f docker-compose-dev.yml run --rm -it backend bash  Releasing Patch version\n$ ./gradlew release  Major version\n$ VERSION=3.7.0 \u0026amp;\u0026amp; ./gradlew release -Prelease.releaseVersion=${VERSION} -Prelease.newVersion=${VERSION}  "
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.12/en/api/",
	"title": "API",
	"tags": [],
	"description": "",
	"content": " APIs  V1 Network API   "
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.12/en/4-developing/generating-docs/",
	"title": "Generating the docs",
	"tags": [],
	"description": "",
	"content": " Requirements  Hugo 0.55.4  Live docs preview To se the current docs just type\nhugo server --source docs  Generating doc statics DPS uses Hugo to generate static docs. To generate the HTML use the following\n$ ./builder.bash docs  "
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.12/en/2-features/solving-host-machine-ip/",
	"title": "Solve host machine IP from anywhere",
	"tags": [],
	"description": "",
	"content": "Just use host.docker\n$ ping host.docker PING host.docker (172.21.0.1) 56(84) bytes of data. 64 bytes from 172.21.0.1 (172.21.0.1): icmp_seq=1 ttl=64 time=0.086 ms 64 bytes from 172.21.0.1 (172.21.0.1): icmp_seq=2 ttl=64 time=0.076 ms 64 bytes from 172.21.0.1 (172.21.0.1): icmp_seq=3 ttl=64 time=0.081 ms  You can customize this hostname by setting\nEnvironment variable\n$ docker run dns-proxy-server -e MG_HOST_MACHINE_HOSTNAME=$(cat /etc/hostname)  Command line option\n$ ./dns-proxy-server --host-machine-hostname $(cat /etc/hostname)  Json configuration\n{ \u0026quot;hostMachineHostname\u0026quot;: \u0026quot;host.docker\u0026quot; }  Notes:\nBe aware if you set the host machine hostname as the machine name then you will have to remove its name from /etc/hosts since OS try to resolve names from hosts file first then from DNS server\n"
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.12/en/2-features/accessing-container-by-name/",
	"title": "Access container by its container name / service name",
	"tags": [],
	"description": "",
	"content": "It\u0026rsquo;s possible solve containers by their container or service name, consider the following sample, the container my-nginx can be solved by querying the hostname my-nginx.docker, the .docker domain is also configurable by the domain configuration json property.\n$ docker run --rm --name my-nginx nginx  $ nslookup my-nginx.docker Server:\t172.17.0.3 Address:\t172.17.0.3#53 Non-authoritative answer: Name:\tmy-nginx.docker Address: 10.0.2.3  You can enable this feature by\nActivating by command line\n./dns-proxy-server -register-container-names  Configuring at json config file\n... \u0026quot;registerContainerNames\u0026quot;: true ...  Using environment variable\nMG_REGISTER_CONTAINER_NAMES=1 ./dns-proxy-server  You can also customize the domain from docker to whatever you want by\nActivating by command line\n./dns-proxy-server --domain docker  Configuring at json config file\n... \u0026quot;domain\u0026quot;: \u0026quot;docker\u0026quot; ...  Using environment variable\nMG_DOMAIN=docker ./dns-proxy-server  "
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.12/en/versions/",
	"title": "Versions",
	"tags": [],
	"description": "",
	"content": " latest 3.12 3.12 3.11 3.9 3.8 3.7 3.6 3.5 3.4 3.3 3.2 3.1 3.0 2.19 2.18 2.15 2.14 2.13  "
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.12/en/2-features/specify-from-which-network-solve-container/",
	"title": "Specify from which network solve container IP",
	"tags": [],
	"description": "",
	"content": "If your container have multiple networks then you can specify which network to use when solving IP by specifying dps.network label.\nCreating a container with two networks attached to\n$ docker network create --attachable network1 $ docker network create --attachable network2 $ docker run --name nginx1 --rm --label dps.network=network1 --hostname server1.acme.com --network network1 nginx $ docker network connect network2 nginx1  Getting networks masks\n$ docker network inspect -f \u0026quot;{{ .IPAM.Config }}\u0026quot; network1 [{172.31.0.0/16 172.31.0.1 map[]}] $ docker network inspect -f \u0026quot;{{ .IPAM.Config }}\u0026quot; network2 [{192.168.16.0/20 192.168.16.1 map[]}]  Solving container and checking that the solved IP will be respective to the configured network at dps.network label\n$ nslookup server1.acme.com Server:\t172.17.0.3 Address:\t172.17.0.3#53 Non-authoritative answer: Name:\tserver1.acme.com Address: 192.168.16.2  "
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.12/en/2-features/dps-network-resolution/",
	"title": "DPS docker network",
	"tags": [],
	"description": "",
	"content": " Since: 2.15.0\nDPS can create its own network which is called dps and connect all running containers to that network this way all containers can comunicate to each other, when container A solve container B IP, which will be able to ping B cause they are on the same network (dps). Observes that you are also able to create your own network and make this job of connect the containers you want to be able to talk each other.\nActivating by command line\n./dns-proxy-server --dps-network-auto-connect  Configuring at json config file\n... \u0026quot;dpsNetworkAutoConnect\u0026quot;: true ...  Using environment variable\nMG_DPS_NETWORK_AUTO_CONNECT=1 ./dns-proxy-server   OBS: with this feature disabled or not, DPS gives priority to solve bridge networks over the others (if a bridge network were found for the container)\n Why it is necessary We can simulate the issue by the following example:\nYou have a container running on an overlay network (so you need to be running docker in a swarm mode), then it means the container can not be accessed by the host or by containers which are not in this same network\ndocker-compose.yml\nversion: '3.2' services: nginx-1: image: nginx container_name: nginx-1 hostname: nginx-1.app networks: - nginx-network networks: nginx-network: driver: overlay attachable: true  starting up the container and testing\n$ docker-compose up $ curl --connect-timeout 2 nginx-1.app curl: (7) Failed to connect to nginx-1.app port 80: Connection timed out  The solution for it can be use dps network or specify a bridge network on the docker-compose.yml\ndocker-compose.yml\nversion: '3.2' services: nginx-1: image: nginx container_name: nginx-1 hostname: nginx-1.app networks: - nginx-network - nginx-network-bridge networks: nginx-network: driver: overlay attachable: true nginx-network-bridge: driver: bridge  $ docker-compose down $ docker-compose up $ curl -I --connect-timeout 2 nginx-1.app HTTP/1.1 200 OK  "
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.12/en/2-features/multiple-environments/",
	"title": "Multiple Environments",
	"tags": [],
	"description": "",
	"content": "As DPS 2.18 you can group your hostnames by environments, this is a very useful feature when you wanna solve the same hostname to different IPs depending of what you\u0026rsquo;re doing, e.g developing in your machine or testing the QA environment as the example below:\nLet\u0026rsquo;s say you\u0026rsquo;re developing at the acme.com so you wanna solve it to your local machine, then you can configure DPS local entries as the following\nWhen you are done with your work and deployed to the QA environment and wanna test it, let\u0026rsquo;s say your app is deployed at the QA machine addressed by the IP 192.168.0.50, so you can create a new env on DPS e.g. QA and create the acme.com A record pointing to the 192.168.0.50 address.\nThis way you can swap between local and qa environments in a fast and convenient approach\n"
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.12/en/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.12/en/5-tutorials/docker-reverse-proxy/",
	"title": "Configuring a Service Discovery solution on Docker using DNS Proxy Server and NGINX",
	"tags": [],
	"description": "",
	"content": " Requirements  DPS already configured, see the docs if you haven\u0026rsquo;t yet.  Tested on:  DPS 3.11 OS: Mac, Linux  Introducing You will see how to develop with docker containers solving them by hostnames from your host machine as the following picture shows:\nif you know about DPS you will figure out that\u0026rsquo;s a very basic DPS feature and you don\u0026rsquo;t need complex configurations to achieve that, except on MAC and Windows as docker runs its containers on a virtual machine so DPS default feature to solve containers names will work but the solved IPs are worthless because they aren\u0026rsquo;t accessible from the host.\nTo fix that we will configure an API Gateway, Service Discovery, Reverse Proxy solution combining DPS with Nginx, see final solution below:\n Obs: This tutorial won\u0026rsquo;t work on Windows yet because containers solving is not support yet, follow the feature request issue on github.\n Source: excalidraw\nConfiguring The pratice is simpler than the theory, let\u0026rsquo;s get it working:\nConfiguring Nginx reverse proxy and two web apps for test\n$ git clone https://github.com/mageddo/dns-proxy-server.git $ cd examples/api-gateway_service-discovery_reverse-proxyame-compose-file $ docker-compose up --build  docker-compose up created three containers, the first is a nginx reverse proxy which will listen to the host machine 80 port and two others are web apps which the reverse proxy will proxy to depending on the hostname queried.\nReverse Proxy will listen all .webapp hostnames and proxy to .container containers.\nSee docker-compose.yml for more details about each docker service.\nThe final step is to configure a wildcard to handle when something on the host queries for .webapp:\nTesting From the hostname Web app 1 is working:\n$ curl -i -X GET http://web-app.webapp HTTP/1.1 200 OK Server: nginx/1.23.3 Date: Thu, 16 Mar 2023 03:18:53 GMT Content-Type: text/html Content-Length: 37 Connection: keep-alive Last-Modified: Thu, 16 Mar 2023 02:35:50 GMT ETag: \u0026quot;64128086-25\u0026quot; Accept-Ranges: bytes \u0026lt;h1\u0026gt;Hello World from web-app!!!\u0026lt;/h1\u0026gt;  Web app 2 is also working:\n$ curl -i -X GET http://web-app-2.webapp HTTP/1.1 200 OK Server: nginx/1.23.3 Date: Thu, 16 Mar 2023 03:30:19 GMT Content-Type: text/html Content-Length: 615 Connection: keep-alive Last-Modified: Tue, 13 Dec 2022 15:53:53 GMT ETag: \u0026quot;6398a011-267\u0026quot; Accept-Ranges: bytes \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Welcome to nginx!\u0026lt;/title\u0026gt; ...  Apps can also access each other by its hostname No reverse proxy is necessary here, so you can connect a web-app to a database container by its hostname for example.\nweb-app-1 connecting to web-app-2\n$ docker-compose run web-app curl -I web-app-2.webapp.container HTTP/1.1 200 OK Server: nginx/1.23.3 Date: Thu, 16 Mar 2023 03:55:02 GMT Content-Type: text/html Content-Length: 615 Last-Modified: Tue, 13 Dec 2022 15:53:53 GMT Connection: keep-alive  That\u0026rsquo;s all, if you have any contribution or question feel free to open a pull request or an issue on the Github repo, thanks for reading.\n Service Discovery, API Gateway, Service Discovery, Reverse Proxy\n "
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.12/en/credits/",
	"title": "Credits",
	"tags": [],
	"description": "",
	"content": " Contributors Thanks to them  for making Open Source Software a better place !\n.ghContributors{ display:flex; flex-flow: wrap; align-content: flex-start }\n.ghContributors \u0026gt; div{ width: 50% ; display: inline-flex; margin-bottom: 5px; } .ghContributors \u0026gt; div label{ padding-left: 4px ; } .ghContributors \u0026gt; div span{ font-size: x-small; padding-left: 4px ; }\n  @mageddo 748 commits \n @josielrocha 9 commits \n @mrubli 3 commits \n @addshore 3 commits \n @AJenbo 1 commits \n @dvarrazzo 1 commits \n @imartinezortiz 1 commits \n\n"
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.12/en/",
	"title": "Getting Started",
	"tags": [],
	"description": "",
	"content": " Main features DPS is a lightweight end user (Developers, Server Administrators) DNS server tool which make it easy to develop in systems where one hostname can solve to different IPs based on the configured environment, so you can:\n Solve hostnames from local configuration database Solve hostnames from docker containers using docker hostname option or HOSTNAMES env Solve hostnames from a list of configured remote DNS servers(as a proxy) if no answer of two above Solve hostnames using wildcards Graphic interface to Create/List/Update/Delete A/CNAME records Solve host machine IP using host.docker hostname Access container by its container name / service name Specify from which network solve container IP  "
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.12/en/showcase/",
	"title": "Showcase",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.12/en/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]