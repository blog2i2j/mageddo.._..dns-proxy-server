[
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.9/en/2-features/auto-configuration-as-default-dns/",
	"title": "Auto configure host default DNS",
	"tags": [],
	"description": "",
	"content": " DPS will configure itself as the default machine DNS when running on standalone mode (not on docker).\nActivation This feature is active by default and can be disabled by defaultDns json config or -default-dns commandline arg.\nPlatform Support Check the following table to understand the support at every platform:\n✅: Fully supported, ❌: Not supported, ⚠️: Partially supported\n   Platform Support Description     Linux ✅ Will use system-resolved when avaible or /etc/resolv.conf, check MG_RESOLVCONF env check which file will be configured, see running on Linux for more details   MAC OSX ✅ DPS will use networksetup to configure the DNS, check running on MAC to see more details   Windows ❌ Windows is not supported yet but there is an issue to solve that    Docker Limitations When you run DPS on docker it won\u0026rsquo;t be able to configure itself as the default host DNS depending on your environment, so you will need to that manually, see specific running it instructions for your platform for more details.\n"
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.9/en/1-getting-started/",
	"title": "Getting Started",
	"tags": [],
	"description": "",
	"content": "Redirecting to running it page \u0026hellip;\n"
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.9/en/1-getting-started/running-it/linux/",
	"title": "Linux running instructions",
	"tags": [],
	"description": "",
	"content": " Running on Linux Standalone run (Recommended) Download the latest release, extract and run:\n$ sudo ./dns-proxy-server  Now DNS Proxy Server is your DNS server, to back everything to original state just press CTRL + C;\nOn Docker  Actually, I recommend you to run DPS using standalone method when you want DPS to be automatically configured as the default DNS\n $ docker run --rm --hostname dns.mageddo --name dns-proxy-server -p 5380:5380 \\ --network host \\ -v /var/run/docker.sock:/var/run/docker.sock \\ -v /etc/systemd/:/host/etc/systemd \\ -v /etc/:/host/etc \\ defreitas/dns-proxy-server  If you\u0026rsquo;re using system-resolved then run command below to restart systemd-resolved service and make DPS as default DNS changes to take effect.\n$ service systemd-resolved restart  Explaining:\n--network host: Running on host mode make it possible to DPS bind the DNS server port to the host network interface, this way all containers will have access to DPS address and use DPS features. If you don\u0026rsquo;t want to use that option then you can consider use DPS Network feature.\n/var/run/docker.sock: Docker socket, so DPS can query the running containers and solve their IP when asked.\n/etc/systemd/:/host/etc/systemd / /etc/:/host/etc: Depending on your distro you may are using system-resolved or vanila resolv.conf to configure available DNS Servers, DPS will look at both and choose the best to be configured.\n"
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.9/en/1-getting-started/running-it/mac/",
	"title": "MacOSX running instructions",
	"tags": [],
	"description": "",
	"content": " Running on MAC DPS actually is fully supported on MAC except by docker limitation features. Despite on this, there is no additional configuration to run DPS on Mac, you can do just like on Linux.\nDownload the latest release, extract and run:\n$ sudo ./dns-proxy-server  When running on standalone mode (not on docker container) DPS will be able to auto-configure itself as OSX default DNS, after 5 seconds you see something like usingDnsConfigurator=DnsConfiguratorOSx at the logs.\nConfiguring DPS as default DNS manually If by some reason it doesn\u0026rsquo;t work or you want to configure it manually because are running DPS on a docker conainer, then check the instructions bellow:\nTo list available networks:\n$ networksetup -listallnetworkservices An asterisk (*) denotes that a network service is disabled. USB 10/100/1000 LAN Wi-Fi Thunderbolt Bridge  In my case the right Network is Wi-Fi, before change anything let\u0026rsquo;s check if it has some manual configured DNS server:\n$ networksetup -getdnsservers Wi-Fi There aren't any DNS Servers set on Wi-Fi.  If it returns some server IP then is a good idea to save it to restore the configurations later.\nLet\u0026rsquo;s set DPS as the default DNS Server, you can get DPS IP by search for Starting UDP server at the starting logs, it\u0026rsquo;s 192.168.0.14 in my case, remember you need to run DPS in port 53 as MAC doesn\u0026rsquo;t accept custom port especification.\n$ networksetup -setdnsservers Wi-Fi 192.168.0.14  If you need to remove the configured DNS server then it will use your network provider DNS\n$ networksetup -setdnsservers Wi-Fi Empty  See this thread with more use cases.\n"
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.9/en/1-getting-started/running-it/",
	"title": "Running it",
	"tags": [],
	"description": "",
	"content": " Specific Instructions  Linux running instructions   MacOSX running instructions   Windows running instructions   General Instructions The process to running DPS is basically the same for all platforms, except by Windows which don\u0026rsquo;t support auto configuration as default DNS.\nDownload the latest release for your platform\nStart DPS\nsudo ./dns-proxy-server  Then you can solve from pre-configured entries (conf/config.json):\n$ ping dps-sample.dev PING dps-sample.dev (192.168.0.254) 56(84) bytes of data.  Also solve Docker containers:\n$ docker run --rm --hostname nginx.dev nginx $ ping nginx.dev PING nginx.dev (172.17.0.4) 56(84) bytes of data. 64 bytes from 172.17.0.4 (172.17.0.4): icmp_seq=1 ttl=64 time=0.043 ms 64 bytes from 172.17.0.4 (172.17.0.4): icmp_seq=2 ttl=64 time=0.022 ms  Running on Docker See specific running instructions to check how is possible to set DPS as default DNS on docker at your platform or set as default DNS automatically feature docker limitations for more details.\n"
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.9/en/api/v1/networks/",
	"title": "V1 Network API",
	"tags": [],
	"description": "",
	"content": " Disconnect containers from network DELETE /network/disconnect-containers HTTP/1.1  Parameters\n   Name Type Decription     netoworkId string The networkId which the containers will be disconnected from    Reponse\nHTTP/1.1 200 [ \u0026quot;success for 551adbb704bf95ae73f3f8e497560609d2016d1566196298f1787f087af4b5cd\u0026quot;, \u0026quot;success for 5f5ce51404b15069795006e7319f270db4f6d822a067e61808eeb0b2922087db\u0026quot; ]  Example\n$ curl -X DELETE dns.mageddo:5380/network/disconnect-containers/?networkId=85e7564c6b71  "
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.9/en/1-getting-started/running-it/windows/",
	"title": "Windows running instructions",
	"tags": [],
	"description": "",
	"content": " Running on Windows You can run DPS on Windows host without any problems except by two features\n DPS won\u0026rsquo;t be able to be set as default DNS automatically (instructions below) DPS isn\u0026rsquo;t capable yet (see backlog issue) to connect to docker API and solve containers   Start up DPS\ndocker run --name dns-proxy-server -p 5380:5380 -p 53:53/udp \\ -v /var/run/docker.sock:/var/run/docker.sock \\ defreitas/dns-proxy-server  Change your default internet adapter DNS to 127.0.0.1\n   Press Windows + R and type ncpa.cpl then press enter or go to your network interfaces Window Change your default internet adapter DNS to 127.0.0.1 by following the pictures below  Uncheck IPV6 because Windows can try to solve hostnames by using a IPV6 DNS server, then requests won\u0026rsquo;t be sent to DPS, actually DPS doesn\u0026rsquo;t support IPV6.\nTesting the DNS server Starting some docker container and keeping it alive for DNS queries\n$ docker run --rm --hostname nginx.dev.intranet \\ -e 'HOSTNAMES=nginx2.dev.intranet,nginx3.dev.intranet' nginx  Solving the docker container hostname from Dns Proxy Server\n$ nslookup nginx.dev.intranet Server:\t172.22.0.6 Address:\t172.22.0.6#53 Non-authoritative answer: Name:\tdebian.dev.intranet Address: 172.22.0.7  Google keep working was well\n$ nslookup google.com Server:\t172.22.0.6 Address:\t172.22.0.6#53 Non-authoritative answer: Name:\tgoogle.com Address: 172.217.29.206  Start the server at custom port and solving from it\n$ nslookup -port=8980 google.com 127.0.0.1  "
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.9/en/2-features/",
	"title": "Features",
	"tags": [],
	"description": "",
	"content": " Features  Auto configure host default DNS   GUI Dashboard   Installing DPS as service   Different Docker Networks Solving   Wildcards hostnames Solving   Configuring logs   Solve host machine IP from anywhere   Access container by its container name / service name   Specify from which network solve container IP   DPS docker network   Multiple Environments   DNS resolution order DPS follow the below order to solve hostnames\n Try to solve the hostname from docker containers Then from local database file Then from 3rd configured remote DNS servers  "
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.9/en/2-features/gui/",
	"title": "GUI Dashboard",
	"tags": [],
	"description": "",
	"content": " Manage local DNS records Actually you can create/edit/delete A and CNAME entries using the GUI accessing http://localhost:5380 or http://dns.mageddo or by editing the config.json.\n"
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.9/en/2-features/installing-as-service/",
	"title": "Installing DPS as service",
	"tags": [],
	"description": "",
	"content": " Installing as docker service docker run --hostname dns.mageddo --name dns-proxy-server -p 5380:5380 \\ --restart=unless-stopped -d \\ -v /opt/dns-proxy-server/conf:/app/conf \\ -v /var/run/docker.sock:/var/run/docker.sock \\ -v /etc/resolv.conf:/etc/resolv.conf \\ defreitas/dns-proxy-server  Installing as linux service  Download the latest release and extract it Run the service installer  $ sudo ./dns-proxy-server -service=docker   Then follow the progress at the log file  $ tail -f /var/log/dns-proxy-server.log   this way it will start with the OS\nif you want to stop\n$ sudo service dns-proxy-server stop Stopping service… Service stopped  if you don\u0026rsquo;t want this service anymore\n$ sudo service dns-proxy-server uninstall Are you really sure you want to uninstall this service? That cannot be undone. [yes|No] yes  "
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.9/en/1-getting-started/requirements/",
	"title": "Requirements",
	"tags": [],
	"description": "",
	"content": " Requirements  Linux/Windows Docker 1.9.x (Only if you run DPS using docker or want to solve docker containers hostname using DPS)  MAC Support Based on users feedback, DPS don\u0026rsquo;t work on MAC, unfortunatly I don\u0026rsquo;t have a MAC computer to work on that, if you want to contribute please try to fix it then open a pull request, sorry for the inconvenience.\n"
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.9/en/3-configuration/",
	"title": "Configuration",
	"tags": [],
	"description": "",
	"content": " JSON configuration Version 2\n{ \u0026quot;version\u0026quot;: 2, // Remote DNS servers to be asked when can not solve from docker or local storage // If no one server was specified then the 8.8.8.8 will be used \u0026quot;remoteDnsServers\u0026quot;: [ \u0026quot;8.8.8.8\u0026quot;, \u0026quot;4.4.4.4:54\u0026quot; ], // all existent environments \u0026quot;envs\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;\u0026quot;, // empty string is the default enviroment \u0026quot;hostnames\u0026quot;: [ // all local hostnames entries { // (optional) used to control it will be automatically generated if not passed \u0026quot;id\u0026quot;: 1, \u0026quot;hostname\u0026quot;: \u0026quot;github.com\u0026quot;, \u0026quot;ip\u0026quot;: \u0026quot;192.168.0.1\u0026quot;, \u0026quot;ttl\u0026quot;: 255 // how many seconds cache this entry } ] } ], \u0026quot;activeEnv\u0026quot;: \u0026quot;\u0026quot;, // the current environment keyname \u0026quot;webServerPort\u0026quot;: 0, // web admin port, when 0 the default value is used, see --help option \u0026quot;dnsServerPort\u0026quot;: 8980, // dns server port, when 0 the default value is used \u0026quot;logLevel\u0026quot;: \u0026quot;DEBUG\u0026quot;, \u0026quot;logFile\u0026quot;: \u0026quot;console\u0026quot; // where the log will be written, \u0026quot;registerContainerNames\u0026quot;: false, // if should register container name / service name as a hostname \u0026quot;domain\u0026quot;: \u0026quot;\u0026quot;, // The container names domain \u0026quot;dpsNetwork\u0026quot;: false, // if should create a bridge network for dps container \u0026quot;dpsNetworkAutoConnect\u0026quot;: false // if should connect all containers to dps container }  Version 1\n{ \u0026quot;remoteDnsServers\u0026quot;: [ [8,8,8,8], [4,4,4,4] ], // Remote DNS servers to be asked when can not solve from docker or local storage // If no one server was specified then the 8.8.8.8 will be used \u0026quot;envs\u0026quot;: [ // all existent environments { \u0026quot;name\u0026quot;: \u0026quot;\u0026quot;, // empty string is the default \u0026quot;hostnames\u0026quot;: [ // all local hostnames entries { \u0026quot;id\u0026quot;: 1, \u0026quot;hostname\u0026quot;: \u0026quot;github.com\u0026quot;, \u0026quot;ip\u0026quot;: [192, 168, 0, 1], \u0026quot;ttl\u0026quot;: 255 } ] } ], \u0026quot;activeEnv\u0026quot;: \u0026quot;\u0026quot;, // the default env keyname \u0026quot;lastId\u0026quot;: 1, // hostnames sequence, don't touch here \u0026quot;webServerPort\u0026quot;: 0, // web admin port, when 0 the default value is used, see --help option \u0026quot;dnsServerPort\u0026quot;: 8980, // dns server port, when 0 the default value is used \u0026quot;logLevel\u0026quot;: \u0026quot;DEBUG\u0026quot;, \u0026quot;logFile\u0026quot;: \u0026quot;console\u0026quot; // where the log will be written, \u0026quot;registerContainerNames\u0026quot;: false // if should register container name / service name as a hostname }  Environment variable configuration Boolean values\n You can use 1 or true (case insensitive) to specify which the flag is activated, any other value will be considered false.\n    VARIBLE DESCRIPTION DEFAULT VALUE     MG_RESOLVCONF Linux resolvconf or systemd-resolved path to set DPS as default DNS /host/etc/systemd/resolved.conf,/host/etc/resolv.conf,/etc/systemd/resolved.conf,/etc/resolv.conf   MG_LOG_LEVEL  INFO   MG_LOG_FILE Path where to logs will be stored console   MG_REGISTER_CONTAINER_NAMES if should register container name / service name as a hostname false   MG_HOST_MACHINE_HOSTNAME hostname to solve host machine IP host.docker   MG_DOMAIN The container names domain (requires MG_REGISTER_CONTINER_NAMES=TRUE) .docker    Terminal configuration Usage: \u0026lt;main class\u0026gt; [-default-dns] [-dps-network] [-dps-network-auto-connect] [-help] [-register-container-names] [-service-publish-web-port] [-version] [-conf-path=\u0026lt;configPath\u0026gt;] [-domain=\u0026lt;domain\u0026gt;] [-host-machine-hostname=\u0026lt;hostMachineHostname\u0026gt;] [-log-file=\u0026lt;logToFile\u0026gt;] [-log-level=\u0026lt;logLevel\u0026gt;] [-server-port=\u0026lt;dnsServerPort\u0026gt;] [-service=\u0026lt;service\u0026gt;] [-web-server-port=\u0026lt;webServerPort\u0026gt;] -conf-path, --conf-path=\u0026lt;configPath\u0026gt; The config file path (default conf/config.json) -default-dns, --default-dns This DNS server will be the default server for this machine (default true) -domain, --domain=\u0026lt;domain\u0026gt; Domain utilized to solver containers and services hostnames (default docker) -dps-network, --dps-network Create a bridge network for DPS increasing compatibility (default false) -dps-network-auto-connect, --dps-network-auto-connect Connect all running and new containers to the DPS network, this way you will probably not have resolution issues by acl (implies dps-network=true) (default false) -help, --help This message (default false) -host-machine-hostname, --host-machine-hostname=\u0026lt;hostMachineHostname\u0026gt; The hostname to get host machine IP (default host.docker) -log-file, --log-file=\u0026lt;logToFile\u0026gt; Log to file instead of console, (true=log to default log file, /tmp/log.log=log to custom log location) (default console) -log-level, --log-level=\u0026lt;logLevel\u0026gt; Log Level ERROR, WARNING, INFO, DEBUG (default INFO) -register-container-names, --register-container-names If must register container name / service name as host in DNS server (default false) -server-port, --server-port=\u0026lt;dnsServerPort\u0026gt; The DNS server to start into (default 53) -service, --service=\u0026lt;service\u0026gt; Setup as service, starting with machine at boot docker = start as docker service, normal = start as normal service, uninstall = uninstall the service from machine (default \u0026lt;empty\u0026gt;) -service-publish-web-port, --service-publish-web-port Publish web port when running as service in docker mode (default true) -version, --version Shows the current version (default false) -web-server-port, --web-server-port=\u0026lt;webServerPort\u0026gt; The web server port (default 5380)  "
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.9/en/2-features/docker-different-networks-solving/",
	"title": "Different Docker Networks Solving",
	"tags": [],
	"description": "",
	"content": "DPS can lead with docker containers with different networks, it will find the target container best matching IP, best matching means the IP which have the most chances of be accessible from the client, no distinction if the client is another container or not.\nYou can click here to see a pratical working sample.\nThe following table describles the possible scenarios involving docker container networks, this is an automatic decision made by DPS, if you want to enforce some network resolution you can use dps.network label .\n   DPS Container Network Client Container Network Target Container Network Result Description     any:bridge any:bridge any:bridge OK Everything works fine when all the networks are using bridge driver, no problem if the networks are different   Network x Network x Network x OK Even with restrictive networks (like overlay driver) the resolution will work, since all containers are connected to this same network.   Network a, Network b Network a Network b OK The minimal requirement is that client must be on the same network which DPS so the client will able to query DPS, then client also need to be on the same network which the target container, so it will be able to ping after solve the hostname, DPS don\u0026rsquo;t really need to be able to talk with the target container since it won\u0026rsquo;t turn into a client a some moment    "
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.9/en/2-features/solving-hostnames-wildcard/",
	"title": "Wildcards hostnames Solving",
	"tags": [],
	"description": "",
	"content": "If you register a hostname with . at start, then all subdomains will solve to that container/local storage entry\nExample\ndocker run --rm --hostname .mageddo.com nginx:latest  Now all mageddo.com subdomains will solve to that nginx container\n$ nslookup site1.mageddo.com Server:\t172.17.0.4 Address:\t172.17.0.4#53 Non-authoritative answer: Name:\tsite1.mageddo.com Address: 172.17.0.5 $ nslookup mageddo.com Server:\t172.17.0.4 Address:\t172.17.0.4#53 Non-authoritative answer: Name:\tmageddo.com Address: 172.17.0.5  "
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.9/en/4-compiling/",
	"title": "Compiling from source",
	"tags": [],
	"description": "",
	"content": " Requirements  JDK 17+  Building from source Build the frontend files (optional)\n./builder.bash build-frontend  Build and run the program\n$ ./gradlew build compTest -Dquarkus.package.type=uber-jar \u0026amp;\u0026amp; java -jar ./build/dns-proxy-server.jar  "
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.9/en/2-features/logs/",
	"title": "Configuring logs",
	"tags": [],
	"description": "",
	"content": " Configuring log output You can disable, log to console, log to default log file path or specify a log path at config file, environment or command line argument. Available options:\n console (default) - log to console false - Logs are disabled true - stop log to console and log to /var/log/dns-proxy-server.log file  eg. /tmp/log.log - log to specified path  Config File\n{ ... \u0026quot;logFile\u0026quot;: \u0026quot;console\u0026quot; ... }  Environment\nexport MG_LOG_FILE=console  Command line argument\n./dns-proxy-server -log-file=console  Configuring log level You can change system log level using environment variable, config file, or command line argument, DPS will consider the parameters in that order, first is more important.\nAvailable levels:\n ERROR WARNING INFO (Default) DEBUG  Environment\nexport MG_LOG_LEVEL=DEBUG  Config file\n{ ... \u0026quot;logLevel\u0026quot;: \u0026quot;DEBUG\u0026quot; ... }  Command line argument\n./dns-proxy-server -log-level=DEBUG  "
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.9/en/5-developing/",
	"title": "Developing at the project",
	"tags": [],
	"description": "",
	"content": " Vanilla Developing Backend\n$ ./gradlew quarkusDev  Make your DNS queries to IP and TCP/UDP ports indicated at the console log.\nFront end app (optional)\n$ cd app \u0026amp;\u0026amp; npm start  Then access http://localhost:3000/ , front end will proxy to http://localhost:5380 backend.\nWith Docker $ ./gradlew build -Dquarkus.package.type=uber-jar -i -x check $ docker-compose -f docker-compose-dev.yml up  or\n$ ./gradlew build -Dquarkus.package.type=uber-jar -i -x check $ docker-compose -f docker-compose-dev.yml run --rm -it backend bash  Releasing Patch version\n$ ./gradlew release  Major version\n$ VERSION=3.7.0 \u0026amp;\u0026amp; ./gradlew release -Prelease.releaseVersion=${VERSION} -Prelease.newVersion=${VERSION}  "
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.9/en/6-generating-docs/",
	"title": "Generating the docs",
	"tags": [],
	"description": "",
	"content": " Requirements  Hugo 0.55.4  Live docs preview To se the current docs just type\nhugo server --source docs  Generating doc statics DPS uses Hugo to generate static docs. To generate the HTML use the following\n$ ./builder.bash docs  "
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.9/en/2-features/solving-host-machine-ip/",
	"title": "Solve host machine IP from anywhere",
	"tags": [],
	"description": "",
	"content": "Just use host.docker\n$ ping host.docker PING host.docker (172.21.0.1) 56(84) bytes of data. 64 bytes from 172.21.0.1 (172.21.0.1): icmp_seq=1 ttl=64 time=0.086 ms 64 bytes from 172.21.0.1 (172.21.0.1): icmp_seq=2 ttl=64 time=0.076 ms 64 bytes from 172.21.0.1 (172.21.0.1): icmp_seq=3 ttl=64 time=0.081 ms  You can customize this hostname by setting\nEnvironment variable\n$ docker run dns-proxy-server -e MG_HOST_MACHINE_HOSTNAME=$(cat /etc/hostname)  Command line option\n$ ./dns-proxy-server --host-machine-hostname $(cat /etc/hostname)  Json configuration\n{ \u0026quot;hostMachineHostname\u0026quot;: \u0026quot;host.docker\u0026quot; }  Notes:\nBe aware if you set the host machine hostname as the machine name then you will have to remove its name from /etc/hosts since OS try to resolve names from hosts file first then from DNS server\n"
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.9/en/api/",
	"title": "API",
	"tags": [],
	"description": "",
	"content": " APIs  V1 Network API   "
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.9/en/2-features/accessing-container-by-name/",
	"title": "Access container by its container name / service name",
	"tags": [],
	"description": "",
	"content": "It\u0026rsquo;s possible solve containers by their container or service name, consider the following sample, the container my-nginx can be solved by querying the hostname my-nginx.docker, the .docker domain is also configurable by the domain configuration json property.\n$ docker run --rm --name my-nginx nginx  $ nslookup my-nginx.docker Server:\t172.17.0.3 Address:\t172.17.0.3#53 Non-authoritative answer: Name:\tmy-nginx.docker Address: 10.0.2.3  You can enable this feature by\nActivating by command line\n./dns-proxy-server -register-container-names  Configuring at json config file\n... \u0026quot;registerContainerNames\u0026quot;: true ...  Using environment variable\nMG_REGISTER_CONTAINER_NAMES=1 ./dns-proxy-server  You can also customize the domain from docker to whatever you want by\nActivating by command line\n./dns-proxy-server --domain docker  Configuring at json config file\n... \u0026quot;domain\u0026quot;: \u0026quot;docker\u0026quot; ...  Using environment variable\nMG_DOMAIN=docker ./dns-proxy-server  "
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.9/en/2-features/specify-from-which-network-solve-container/",
	"title": "Specify from which network solve container IP",
	"tags": [],
	"description": "",
	"content": "If your container have multiple networks then you can specify which network to use when solving IP by specifying dps.network label.\nCreating a container with two networks attached to\n$ docker network create --attachable network1 $ docker network create --attachable network2 $ docker run --name nginx1 --rm --label dps.network=network1 --hostname server1.acme.com --network network1 nginx $ docker network connect network2 nginx1  Getting networks masks\n$ docker network inspect -f \u0026quot;{{ .IPAM.Config }}\u0026quot; network1 [{172.31.0.0/16 172.31.0.1 map[]}] $ docker network inspect -f \u0026quot;{{ .IPAM.Config }}\u0026quot; network2 [{192.168.16.0/20 192.168.16.1 map[]}]  Solving container and checking that the solved IP will be respective to the configured network at dps.network label\n$ nslookup server1.acme.com Server:\t172.17.0.3 Address:\t172.17.0.3#53 Non-authoritative answer: Name:\tserver1.acme.com Address: 192.168.16.2  "
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.9/en/versions/",
	"title": "Versions",
	"tags": [],
	"description": "",
	"content": " latest 3.9 3.9 3.8 3.7 3.6 3.5 3.4 3.3 3.2 3.1 3.0 2.19 2.18 2.15 2.14 2.13  "
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.9/en/2-features/dps-network-resolution/",
	"title": "DPS docker network",
	"tags": [],
	"description": "",
	"content": " Since: 2.15.0\nDPS can create its own network which is called dps and connect all running containers to that network this way all containers can comunicate to each other, when container A solve container B IP, which will be able to ping B cause they are on the same network (dps). Observes that you are also able to create your own network and make this job of connect the containers you want to be able to talk each other.\nActivating by command line\n./dns-proxy-server --dps-network-auto-connect  Configuring at json config file\n... \u0026quot;dpsNetworkAutoConnect\u0026quot;: true ...  Using environment variable\nMG_DPS_NETWORK_AUTO_CONNECT=1 ./dns-proxy-server   OBS: with this feature disabled or not, DPS gives priority to solve bridge networks over the others (if a bridge network were found for the container)\n Why it is necessary We can simulate the issue by the following example:\nYou have a container running on an overlay network (so you need to be running docker in a swarm mode), then it means the container can not be accessed by the host or by containers which are not in this same network\ndocker-compose.yml\nversion: '3.2' services: nginx-1: image: nginx container_name: nginx-1 hostname: nginx-1.app networks: - nginx-network networks: nginx-network: driver: overlay attachable: true  starting up the container and testing\n$ docker-compose up $ curl --connect-timeout 2 nginx-1.app curl: (7) Failed to connect to nginx-1.app port 80: Connection timed out  The solution for it can be use dps network or specify a bridge network on the docker-compose.yml\ndocker-compose.yml\nversion: '3.2' services: nginx-1: image: nginx container_name: nginx-1 hostname: nginx-1.app networks: - nginx-network - nginx-network-bridge networks: nginx-network: driver: overlay attachable: true nginx-network-bridge: driver: bridge  $ docker-compose down $ docker-compose up $ curl -I --connect-timeout 2 nginx-1.app HTTP/1.1 200 OK  "
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.9/en/2-features/multiple-environments/",
	"title": "Multiple Environments",
	"tags": [],
	"description": "",
	"content": "As DPS 2.18 you can group your hostnames by environments, this is a very useful feature when you wanna solve the same hostname to different IPs depending of what you\u0026rsquo;re doing, e.g developing in your machine or testing the QA environment as the example below:\nLet\u0026rsquo;s say you\u0026rsquo;re developing at the acme.com so you wanna solve it to your local machine, then you can configure DPS local entries as the following\nWhen you are done with your work and deployed to the QA environment and wanna test it, let\u0026rsquo;s say your app is deployed at the QA machine addressed by the IP 192.168.0.50, so you can create a new env on DPS e.g. QA and create the acme.com A record pointing to the 192.168.0.50 address.\nThis way you can swap between local and qa environments in a fast and convenient approach\n"
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.9/en/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.9/en/credits/",
	"title": "Credits",
	"tags": [],
	"description": "",
	"content": " Contributors Thanks to them  for making Open Source Software a better place !\n.ghContributors{ display:flex; flex-flow: wrap; align-content: flex-start }\n.ghContributors \u0026gt; div{ width: 50% ; display: inline-flex; margin-bottom: 5px; } .ghContributors \u0026gt; div label{ padding-left: 4px ; } .ghContributors \u0026gt; div span{ font-size: x-small; padding-left: 4px ; }\n  @mageddo 738 commits \n @josielrocha 9 commits \n @mrubli 3 commits \n @addshore 3 commits \n @AJenbo 1 commits \n @dvarrazzo 1 commits \n @imartinezortiz 1 commits \n\n"
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.9/en/",
	"title": "Getting Started",
	"tags": [],
	"description": "",
	"content": " Main features DPS is a lightweight end user (Developers, Server Administrators) DNS server tool which make it easy to develop in systems where one hostname can solve to different IPs based on the configured environment, so you can:\n Solve hostnames from local configuration database Solve hostnames from docker containers using docker hostname option or HOSTNAMES env Solve hostnames from a list of configured remote DNS servers(as a proxy) if no answer of two above Solve hostnames using wildcards Graphic interface to Create/List/Update/Delete A/CNAME records Solve host machine IP using host.docker hostname Access container by its container name / service name Specify from which network solve container IP  "
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.9/en/showcase/",
	"title": "Showcase",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/3.9/en/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]