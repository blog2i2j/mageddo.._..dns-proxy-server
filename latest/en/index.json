[
{
	"uri": "http://mageddo.github.io/dns-proxy-server/latest/en/2-features/auto-configuration-as-default-dns/",
	"title": "Auto configure host default DNS",
	"tags": [],
	"description": "",
	"content": " DPS will configure itself as the default machine DNS when running on standalone mode (not on docker).\nActivation This feature is active by default and can be disabled by defaultDns json config or -default-dns commandline arg.\nPlatform Support Check the following table to understand the support at every platform:\n✅: Fully supported, ❌: Not supported, ⚠️: Partially supported\n   Platform Support Description     Linux ✅ Will use system-resolved when avaible or /etc/resolv.conf, check MG_RESOLVCONF env check which file will be configured, see running on Linux for more details   MAC OSX ✅ DPS will use networksetup to configure the DNS, check running on MAC to see more details   Windows ✅ Will configure available network interfaces to query DPS as the default DNS, you can see available networks by running ncpa.cpl    Docker Limitations When you run DPS on docker it won\u0026rsquo;t be able to configure itself as the default host DNS depending on your environment, so you will need to that manually, see specific running it instructions for your platform for more details.\n"
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/latest/en/1-getting-started/",
	"title": "Getting Started",
	"tags": [],
	"description": "",
	"content": "Redirecting to running it page \u0026hellip;\n"
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/latest/en/1-getting-started/running-it/linux/",
	"title": "Linux running instructions",
	"tags": [],
	"description": "",
	"content": " Running on Linux Standalone run Download the latest release, extract and run:\n$ sudo ./dns-proxy-server  Now DNS Proxy Server is your DNS server, to back everything to original state just press CTRL + C;\nClick here to see usage samples\nRunning as Docker Service If you are using docker on your machine that\u0026rsquo;s the best choice as it will automatically start DPS on every boot:\n$ docker run --hostname dns.mageddo --restart=unless-stopped -d \\ -p 5354:53/tcp \\ -p 5354:53/udp \\ -p 5380:5380 \\ -v /var/run/docker.sock:/var/run/docker.sock \\ defreitas/dns-proxy-server  Explaining the running params:\n--network host: Running on host mode make it possible to DPS bind the DNS server port to the host network interface, this way all containers will have access to DPS address and use DPS features. If you don\u0026rsquo;t want to use that option then you can consider use DPS Network feature.\n/var/run/docker.sock: Docker socket, so DPS can query the running containers and solve their IP when asked.\n5354:53 publishing on port 5354 instead of 53 to evict port conflicts\nIn case you do have systemd-resolved installed: You can run DPS on different port if you are having conflicts as system-resolved suports custom ports. But you will need to configure DPS as default DPS manually, check the instructions below:\nGet your local network card IP, to list available networks run:\n$ ip addr 1: lo: \u0026lt;LOOPBACK,UP,LOWER_UP\u0026gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever 2: eno1: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000 link/ether e0:d5:5f:b7:8a:1a brd ff:ff:ff:ff:ff:ff altname enp0s31f6 inet 192.168.0.128/24 brd 192.168.0.255 scope global dynamic noprefixroute eno1 valid_lft 3011sec preferred_lft 3011sec  In my case the right Network is en01 with IP 192.168.0.128, 127.0.0.1 will partially works because this way containers won\u0026rsquo;t be able to solve each other, just the host solve the containers.\nEdit systemd-resolved conf file with the found IP\n$ cat /etc/systemd/resolved.conf ... [Resolve] DNS=192.168.0.128:5354  Then restart the service:\n$ service systemd-resolved restart  In case you don\u0026rsquo;t have systemd-resolved installed: If you don\u0026rsquo;t have systemd-resolved installed then you can volume resolv.conf with the option -v /etc/:/host/etc when running the container but will need to publish DPS on port 53 instead of 5354, don\u0026rsquo;t use that if you have systemd-resolved installed because it will cause docker DNS misconfiguration.\nTesting Once configured, click here to see usage samples.\n"
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/latest/en/1-getting-started/running-it/mac/",
	"title": "MacOSX running instructions",
	"tags": [],
	"description": "",
	"content": " Running on MAC DPS actually is fully supported on MAC knowing docker limitation features which can be bypassed with a reverse-proxy.\nRunning as Docker as service Running DPS as docker service\n$ docker run -d -p 5380:5380 -p 53:53/udp -p 53:53/tcp --restart=unless-stopped \\ -v /var/run/docker.sock:/var/run/docker.sock \\ defreitas/dns-proxy-server   Go to configuring DPS as default DNS to complete DPS configuration. Check this for usage samples.  Standalone run Download the latest release (I recomend the jar one), extract and run:\n$ sudo java -jar ./dns-proxy-server  Check this for usage samples.\nWhen running on standalone mode (not on docker container) DPS will be able to auto configure itself as OSX default DNS, after 5 seconds you see something like usingDnsConfigurator=DnsConfiguratorOSx at the logs.\nConfiguring DPS as default DNS manually When not running in standalone mode you will need to configure DPS as default DPS manually, check the instructions below:\nTo list available networks:\n$ networksetup -listallnetworkservices An asterisk (*) denotes that a network service is disabled. USB 10/100/1000 LAN Wi-Fi Thunderbolt Bridge  In my case the right Network is Wi-Fi, before change anything let\u0026rsquo;s check if it has some manual configured DNS server:\n$ networksetup -getdnsservers Wi-Fi There aren't any DNS Servers set on Wi-Fi.  If it returns some server IP then is a good idea to backup it then you can restore the configurations later.\nLet\u0026rsquo;s set DPS as the default DNS Server, best option here is to get your network IP address, Wi-Fi in my case which has 192.168.0.14 set, 127.0.0.1 will partially works because this way containers won\u0026rsquo;t be able to solve each other, just the host solve the containers.\nObs: Be aware you need to run DPS in port 53 as MAC doesn\u0026rsquo;t accept custom port especification.\n$ networksetup -setdnsservers Wi-Fi 192.168.0.14  If you need to remove the configured DNS server then it will use your network provider DNS\n$ networksetup -setdnsservers Wi-Fi Empty  See this thread with more use cases.\n"
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/latest/en/1-getting-started/running-it/",
	"title": "Running it",
	"tags": [],
	"description": "",
	"content": " Specific Instructions  Linux running instructions   MacOSX running instructions   Windows running instructions   Running as Service If you are using Docker on your machine I recommend to run DPS as a docker service, this way it will automatically be configured whenever you restart the machine, checkout the instructions for Linux, Mac and Windows\nGeneral Instructions The process to running DPS is basically the same for all platforms:\nDownload the latest release for your platform, if no binary available use the jar (requires JRE 21+)\nStart DPS (you need to run as administrator/sudo so DPS can set itself as the default DNS)\nsudo ./dns-proxy-server  Then you can solve from pre-configured entries (conf/config.json):\n$ ping dps-sample.dev PING dps-sample.dev (192.168.0.254) 56(84) bytes of data.  Also solve Docker containers*:\n$ docker run --rm --hostname nginx.dev nginx $ ping nginx.dev PING nginx.dev (172.17.0.4) 56(84) bytes of data. 64 bytes from 172.17.0.4 (172.17.0.4): icmp_seq=1 ttl=64 time=0.043 ms 64 bytes from 172.17.0.4 (172.17.0.4): icmp_seq=2 ttl=64 time=0.022 ms  *Not supported on Windows\nRunning on Docker The standalone way to run DPS on docker can be done by following:\n$ docker run --rm --hostname dns.mageddo -p 5380:5380 -p 53:53/udp defreitas/dns-proxy-server  If you get something like 0.0.0.0:53: bind: address already in use then probably there is some other DNS server like systemd-resolved, so you can try to bind DPS to a specific network interface like 127.0.0.1 or 192.168.x.x, check your local interfaces for the best fit.\n$ docker run --rm --hostname dns.mageddo -p 5380:5380 -p 127.0.0.1:53:53/udp defreitas/dns-proxy-server  You probably want to check on specific OS running instructions to configure all DPS features, when running on docker.\nRunning on docker limitations:\n You have to configure docker as default DNS manually, check specific instructions, to see how to do that you can check more details here.  "
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/latest/en/api/v1/networks/",
	"title": "V1 Network API",
	"tags": [],
	"description": "",
	"content": " Disconnect containers from network DELETE /network/disconnect-containers HTTP/1.1  Parameters\n   Name Type Decription     netoworkId string The networkId which the containers will be disconnected from    Reponse\nHTTP/1.1 200 [ \u0026quot;success for 551adbb704bf95ae73f3f8e497560609d2016d1566196298f1787f087af4b5cd\u0026quot;, \u0026quot;success for 5f5ce51404b15069795006e7319f270db4f6d822a067e61808eeb0b2922087db\u0026quot; ]  Example\n$ curl -X DELETE dns.mageddo:5380/network/disconnect-containers/?networkId=85e7564c6b71  "
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/latest/en/1-getting-started/running-it/windows/",
	"title": "Windows running instructions",
	"tags": [],
	"description": "",
	"content": " Running on Windows DPS actually is fully supported on Windows knowing docker limitation features which can be bypassed with a reverse-proxy.\nRunning as Docker Service 1- If you are using docker on your machine that\u0026rsquo;s the best choice as it will automatically start DPS on every boot:\n$ docker run -d --restart=unless-stopped -p 53:53/udp -p 53:53/tcp -p 5380:5380 -v /var/run/docker.sock:/var/run/docker.sock defreitas/dns-proxy-server  2- Set DPS as the default DNS on Windows, check the instructions below on (Configure DPS as default DNS on Windows) or click here\n3- Now you are able to solve containers form local configuration, also network addresses keep solving as well\n\u0026gt; nslookup dps-sample.dev Server: UnKnown Address: 127.0.0.1 Non-authoritative answer: Name: dps-sample.dev Addresses: 192.168.0.254 192.168.0.254 \u0026gt; nslookup acme.com Server: UnKnown Address: 127.0.0.1 Non-authoritative answer: Name: acme.com Address: 23.93.76.124  You can access the GUI by the address http://localhost:5380/ , see GUI Dashboard feature\nStandalone Run  Download the latest release for Windows Run dps by dns-proxy-server.exe  If you run DPS as administrator then it will capable of configure itself as the default DNS or check instructions below of how to set DPS as default DNS manually.\nConfigure DPS as default DNS on Windows 1. Find the host network ip v4 address\nYou can also use 127.0.0.1 or if don\u0026rsquo;t work your you try the following. On prompt command run ipconfig and get one of the ipv4 addresses, it\u0026rsquo;s recommended to get the IP from the real network card, 192.168.0.128 in my case.\n\u0026gt; ipconfig Windows IP Configuration Ethernet adapter Ethernet: Connection-specific DNS Suffix . : spo.virtua.com.br IPv4 Address. . . . . . . . . . . : 192.168.0.128 Subnet Mask . . . . . . . . . . . : 255.255.255.0 Default Gateway . . . . . . . . . : 192.168.0.1  2. Change your default internet adapter DNS to IP got on the last step\n Press Windows + R and type ncpa.cpl then press enter or go to your network interfaces Window Change your default internet adapter DNS to ip you get the last step 127.0.0.1 or 192.168.0.128 in my case by following the pictures below  Uncheck IPV6 or also configure it with the right IPV6 address for the host machine.\n"
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/latest/en/2-features/",
	"title": "Features",
	"tags": [],
	"description": "",
	"content": " Features  Auto configure host default DNS   GUI Dashboard   Installing DPS as service   Wildcards hostnames Solving   Solving Docker Containers from Hostname   Configuring logs   Solve host machine IP from anywhere   Access container by its container name / service name   Specify from which network solve container IP   DPS Docker Network   Multiple Environments   Different Docker Networks Solving   Local Entries Solving (LocalDB)    IPV4/IPV6 Support  Main features use cases Solving container hostname\n$ nslookup dns.mageddo Server: 127.0.0.53 Address: 127.0.0.53#53 Non-authoritative answer: Name: dns.mageddo Address: 172.157.5.1  Solving host machine IP\n$ nslookup host.docker Server: 127.0.0.53 Address: 127.0.0.53#53 Non-authoritative answer: Name: host.docker Address: 172.157.5.1  Solving from Internet\n$ nslookup acme.com Server: 127.0.0.53 Address: 127.0.0.53#53 Non-authoritative answer: Name: acme.com Address: 23.93.76.124  Solving from local database\n$ nslookup dps-sample.dev Server: 127.0.0.53 Address: 127.0.0.53#53 Non-authoritative answer: Name: dps-sample.dev Address: 192.168.0.254  Access the gui by using http://localhost:5380 , see this link.\nDNS resolution order DPS follow the below order to solve hostnames\n Try to solve the hostname from docker containers Then from local database file Then from 3rd configured remote DNS servers  "
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/latest/en/2-features/gui/",
	"title": "GUI Dashboard",
	"tags": [],
	"description": "",
	"content": " Manage local DNS records Actually you can create/edit/delete A and CNAME entries using the GUI accessing http://localhost:5380 or http://dns.mageddo or by editing the config.json.\n"
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/latest/en/2-features/installing-as-service/",
	"title": "Installing DPS as service",
	"tags": [],
	"description": "",
	"content": " Installing as docker service docker run --hostname dns.mageddo --name dns-proxy-server -p 5380:5380 \\ --restart=unless-stopped -d \\ -v /opt/dns-proxy-server/conf:/app/conf \\ -v /var/run/docker.sock:/var/run/docker.sock \\ -v /etc/resolv.conf:/etc/resolv.conf \\ defreitas/dns-proxy-server  Installing as linux service  Download the latest release and extract it Run the service installer  $ sudo ./dns-proxy-server -service=docker   Then follow the progress at the log file  $ tail -f /var/log/dns-proxy-server.log   this way it will start with the OS\nif you want to stop\n$ sudo service dns-proxy-server stop Stopping service… Service stopped  if you don\u0026rsquo;t want this service anymore\n$ sudo service dns-proxy-server uninstall Are you really sure you want to uninstall this service? That cannot be undone. [yes|No] yes  "
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/latest/en/1-getting-started/requirements/",
	"title": "Requirements",
	"tags": [],
	"description": "",
	"content": " Requirements  Linux/Windows/Mac Docker 1.21.x (Only if you run DPS using docker or want to solve docker containers hostname using DPS) Jre 21+ (When running the jar version)  "
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/latest/en/3-configuration/",
	"title": "Configuration",
	"tags": [],
	"description": "",
	"content": " Configs Remote DNS Servers Remote DNS servers to be asked when can not solve from docker or local storage. Default: 8.8.8.8.\nWeb Server Port Web GUI port, Default: 5380.\nDNS Server Port Default: 53.\nLog Level Default: INFO.\n   Env JSON Terminal     MG_LOG_LEVEL logLevel See \u0026ndash;help    Log File Where the log will be written. Default: console.\n   Env JSON Terminal     MG_LOG_FILE logFile See \u0026ndash;help    Register Container Names If should register container name / service name as a hostname. Default: false.\n   Env JSON Terminal     MG_REGISTER_CONTAINER_NAMES registerContainerNames See \u0026ndash;help    Domain The container names domain used on the registered container, services. Default: docker.\nEx:\ndocker run --rm --name nginx nginx  Will register a container with the name nginx.docker\n   Env JSON Terminal     MG_DOMAIN domain See \u0026ndash;help    DPS Network If should create a bridge network for dps container. Default: false.\nDPS Network Auto Connect If should connect all containers to dps container so they can surely talk with each other. requires DPS Network Option. Default: false.\nDefault DNS If DPS must be set as the default DNS automatically, commonly requires DPS be run as sudo/administrator permissions, this options also won\u0026rsquo;t work in some cases when running inside a docker container, see the feature details.\nHost Machine Hostname Hostname to solve machine IP, domain can be changed by Domain option. Default: host.docker.\n   Env JSON Terminal     MG_HOST_MACHINE_HOSTNAME hostMachineHostname See \u0026ndash;help    Server Protocol Protocol to start the dns server. Default: UDP_TCP.\nDocker Host Docker host address. Default value is SO dependent.\n   Env JSON Terminal     MG_DOCKER_HOST dockerHost See \u0026ndash;help    Resolvconf Override Name Servers If must comment all existing nameservers at resolv.conf file (Linux, MacOS) or just put DPS at the first place. Default: true.\n   Env JSON Terminal     MG_RESOLVCONF_OVERRIDE_NAMESERVERS resolvConfOverrideNameServers See \u0026ndash;help    Resolvconf Linux/Mac resolvconf or systemd-resolved path to set DPS as default DNS. Default: /host/etc/systemd/resolved.conf,/host/etc/resolv.conf,/etc/systemd/resolved.conf,/etc/resolv.conf.\n   Env JSON Terminal     MG_RESOLVCONF  See \u0026ndash;help    No Remote Servers If remote servers like 8.8.8.8 must be disabled and only local solvers like docker containers or local db must be used. Default: false.\n   Env JSON Terminal     MG_NO_REMOTE_SERVERS noRemoteServers See \u0026ndash;help    Active Env Active Env used to query local db entries. Default `` (Empty String).\n   Env JSON Terminal      activeEnv     No Entries Response Code Response code to use when no entries are returned by the configured solvers. Default: 3\n   Env JSON Terminal     MG_NO_ENTRIES_RESPONSE_CODE noEntriesResponseCode See -help    Local Entries Solving (LocalDB) See Local Entries Solving docs.\nDocker Solver Host Machine IP Fallback Whether should answer host machine IP when a matching container is found but it hasn\u0026rsquo;t an IP to be answered, see Github Issue #442. Default: true\n   Env JSON Terminal     MG_DOCKER_SOLVER_HOST_MACHINE_FALLBACK_ACTIVE dockerSolverHostMachineFallbackActive See -help    Example JSON configuration Version 2\n{ \u0026quot;version\u0026quot;: 2, \u0026quot;remoteDnsServers\u0026quot;: [ \u0026quot;8.8.8.8\u0026quot;, \u0026quot;4.4.4.4:54\u0026quot; ], \u0026quot;envs\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;\u0026quot;, // empty string is the default enviroment \u0026quot;hostnames\u0026quot;: [ // all local hostnames entries { \u0026quot;id\u0026quot;: 1, // (optional) used to control it will be automatically generated if not passed \u0026quot;type\u0026quot;: \u0026quot;A\u0026quot;, \u0026quot;hostname\u0026quot;: \u0026quot;github.com\u0026quot;, \u0026quot;ip\u0026quot;: \u0026quot;192.168.0.1\u0026quot;, \u0026quot;ttl\u0026quot;: 255 // how many seconds cache this entry } ] } ], \u0026quot;activeEnv\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;webServerPort\u0026quot;: 5380, \u0026quot;dnsServerPort\u0026quot;: 53, \u0026quot;logLevel\u0026quot;: \u0026quot;INFO\u0026quot;, \u0026quot;logFile\u0026quot;: \u0026quot;console\u0026quot;, \u0026quot;registerContainerNames\u0026quot;: false, \u0026quot;domain\u0026quot;: \u0026quot;docker\u0026quot;, \u0026quot;dpsNetwork\u0026quot;: false, \u0026quot;dpsNetworkAutoConnect\u0026quot;: false, \u0026quot;defaultDns\u0026quot;: true, \u0026quot;hostMachineHostname\u0026quot; : \u0026quot;host.docker\u0026quot;, \u0026quot;serverProtocol\u0026quot;: \u0026quot;UDP_TCP\u0026quot;, \u0026quot;dockerHost\u0026quot;: null, \u0026quot;resolvConfOverrideNameServers\u0026quot;: true, \u0026quot;noRemoteServers\u0026quot;: false, \u0026quot;noEntriesResponseCode\u0026quot;: 3, \u0026quot;dockerSolverHostMachineFallbackActive\u0026quot;: true, \u0026quot;solverRemote\u0026quot; : { \u0026quot;circuitBreaker\u0026quot; : { \u0026quot;failureThreshold\u0026quot; : 3, // how many attempts before open the circuit? \u0026quot;failureThresholdCapacity\u0026quot; : 10, // how many attempts store to the stack? \u0026quot;successThreshold\u0026quot; : 5, // how many attempts before close the circuit? \u0026quot;testDelay\u0026quot; : \u0026quot;PT20S\u0026quot; // how many time to wait before test the circuit again?, see https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html#toString-- for format explanation } } }  Environment variable configuration Boolean values\n You can use 1 or true (case insensitive) to specify which the flag is activated, any other value will be considered false.\n Terminal configuration Run one of the commands below to get the commandline instructions help:\n$ ./dns-proxy-server --help  $ docker run defreitas/dns-proxy-server --help  "
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/latest/en/1-getting-started/versioning/",
	"title": "Release Version Control",
	"tags": [],
	"description": "",
	"content": " DPS Versioning DPS uses semantic versioning [2] for releasing. The latest stable version is the one which is marked as \u0026ldquo;latest\u0026rdquo; label at Github releases or the latest docker tag. Click here to see the binary releases at Github.\nPromotion to the latest (Stable) Minor pre-releases with at least 1 month since they released without a confirmed bug issued on the Github oficial repo, will be released as the latest. A pre-release can take more than 1 month to be promoted to the latest though, if you want to use the most recent updates check the latest pre-release or the docker nightly tag.\nDocker Images There are three types of docker images\n Latest images are the latest stable image for Linux amd64 Nightly/Unstable images are the latest unstable image for Linux amd64 Images for Linux amd64: ex: defreitas/dns-proxy-server:3.9.0 Images for Linux aarch64: ex: defreitas/dns-proxy-server:3.9.0-aarch64  Click here to see the docker images at docker hub.\nRelease Notes You can see every release note on the releases download page or at the release notes.md file\nReference DPS release process was inspired on Gradle and Debian releasing process.\n"
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/latest/en/2-features/solving-hostnames-wildcard/",
	"title": "Wildcards hostnames Solving",
	"tags": [],
	"description": "",
	"content": " Wildcard If you register a hostname with . at start, then all subdomains will solve to that container/local storage entry\nExample\n$ docker run --rm --hostname .mageddo.com nginx:latest  Now all mageddo.com subdomains will solve to that nginx container\n$ nslookup site1.mageddo.com Server:\t172.17.0.4 Address:\t172.17.0.4#53 Non-authoritative answer: Name:\tsite1.mageddo.com Address: 172.17.0.5  $ nslookup mageddo.com Server:\t172.17.0.4 Address:\t172.17.0.4#53 Non-authoritative answer: Name:\tmageddo.com Address: 172.17.0.5  RegEx From DPS 3.14 regex is also supported on localstorage or docker container hostname/HOSTNAMES env, the pattern is /${REGEX}/, everything around the slashes is considered as regex\nExample:\nRunning a sample container\n$ docker run --rm --name nginx1 --hostname '/batata\\.[a-z]+\\.com/' -e 'HOSTNAMES=/\\d+\\.acme\\.com/,/sub\\.acme\\.com/' nginx  Solving\n$ nslookup batata.whatever.com Server:\t127.0.0.1 Address:\t127.0.0.1#53 Non-authoritative answer: Name:\tbatata.whatever.com Address: 172.17.0.4  $ nslookup xpto.acme.com Server:\t127.0.0.1 Address:\t127.0.0.1#53 ** server can't find xpto.acme.com: NXDOMAIN  $ nslookup 123.acme.com Server:\t127.0.0.1 Address:\t127.0.0.1#53 Non-authoritative answer: Name:\t123.acme.com Address: 172.17.0.4  $ nslookup sub.acme.com Server:\t127.0.0.1 Address:\t127.0.0.1#53 Non-authoritative answer: Name:\tsub.acme.com Address: 172.17.0.4  "
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/latest/en/4-developing/compiling/",
	"title": "Compiling from source",
	"tags": [],
	"description": "",
	"content": " Requirements See the requirements.\nBuilding from Source Build the frontend files (optional)\n./builder.bash build-frontend  Build and run the program\nJar file $ ./gradlew clean build compTest shadowJar -i $ java -jar dns-proxy-server-*-all.jar  Native Image $ ./gradlew clean build compTest shadowJar nativeCompile $ ./build/native/nativeCompile/dns-proxy-server  "
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/latest/en/2-features/docker-solving/",
	"title": "Solving Docker Containers from Hostname",
	"tags": [],
	"description": "",
	"content": " DPS can assign a hostname to your docker containers to solve it\u0026rsquo;s IPs by the :\n HOSTNAMES env Container Hostname Container Name Docker Compose Service Name  These are indivual forms of set a hostname to a container to query it, so you only need to use one of them.\nHostnames Env Creating a test container\n$ docker run -e HOSTNAMES=\u0026quot;nginx1.dev,nginx1.docker\u0026quot; nginx  Solving from HOSTNAMES env\n$ dig nginx1.dev @127.0.0.1 +noall +answer nginx1.dev.\t30\tIN\tA\t172.17.0.2 $ dig nginx1.docker @127.0.0.1 +noall +answer nginx1.docker.\t30\tIN\tA\t172.17.0.2  Container Hostname DPS will register the ${Container Hostname} + '.' ${Domain Name} when Domain Name is set, if not set only the Hostname will be used.\nCreating a test container (way 1)\n$ docker run --rm --hostname nginx1 --domainname app nginx  Creating a test container (way 2)\n$ docker run --rm --hostname nginx1.app nginx  Testing hostname\n$ dig nginx1.app @127.0.0.1 +noall +answer nginx1.app.\t30\tIN\tA\t172.17.0.2  Container Name You can solve by the container name, this feature is disabled by default, so you need to enable it using MG_REGISTER_CONTAINER_NAMES=1 env, see a complete tutorial about this feature for more details.\nCreating a test container\n$ docker run --rm --name nginx1 nginx  Testing\n$ dig nginx1.docker @127.0.0.1 +noall +answer nginx1.docker.\t30\tIN\tA\t172.17.0.2  You can customize the .docker domain, with the MG_DOMAIN env, see the docs for more details.\nDocker Compose Service Name Works like Container Name feature, but in this case you can solve by the service name used at the container docker-compose.yml file.\ndocker-compose.yml\nservices: nginx: image: nginx  $ dig nginx.docker @127.0.0.1 +noall +answer nginx.docker.\t30\tIN\tA\t172.23.0.3  Important\nBe aware, when using docker-compose, specially with different docker-compose files you may have to lead with different docker networks limitations.\n"
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/latest/en/5-tutorials/",
	"title": "Tutorials",
	"tags": [],
	"description": "",
	"content": " Tutorials  How to Docker Container Solving Works   Configuring a Service Discovery solution on Docker using DNS Proxy Server and NGINX    Click here to see a set of pratical samples using docker and docker-compose  3rd Tutorials  Resolve Docker Container From Host - @Ankur  \u0026lt;Contribute by opening a Pull Request and link a DPS tutorial here\u0026gt;\n"
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/latest/en/2-features/logs/",
	"title": "Configuring logs",
	"tags": [],
	"description": "",
	"content": " Configuring log output You can disable, log to console, log to default log file path or specify a log path at config file, environment or command line argument. Available options:\n console (default) - log to console false - Logs are disabled true - stop log to console and log to /var/log/dns-proxy-server.log file  eg. /tmp/log.log - log to specified path  Config File\n{ ... \u0026quot;logFile\u0026quot;: \u0026quot;console\u0026quot; ... }  Environment\nexport MG_LOG_FILE=console  Command line argument\n./dns-proxy-server -log-file=console  Configuring log level You can change system log level using environment variable, config file, or command line argument, DPS will consider the parameters in that order, first is more important.\nAvailable levels:\n ERROR WARNING INFO (Default) DEBUG  Environment\nexport MG_LOG_LEVEL=DEBUG  Config file\n{ ... \u0026quot;logLevel\u0026quot;: \u0026quot;DEBUG\u0026quot; ... }  Command line argument\n./dns-proxy-server -log-level=DEBUG  "
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/latest/en/4-developing/",
	"title": "Developing",
	"tags": [],
	"description": "",
	"content": " Requirements See the requirements.\nVanilla Developing Backend Play class com.mageddo.dnsproxyserver.App or run\n$ ./gradlew clean shadowJar \u0026amp;\u0026amp; java -jar ./build/libs/dns-proxy-server-*-all.jar  Make your DNS queries to IP and TCP/UDP ports indicated at the console log.\nFront end app (optional) $ cd app \u0026amp;\u0026amp; npm start  Then access http://localhost:3000/ , front end will proxy to http://localhost:5380 backend.\nDocker Developing $ ./gradlew clean build shadowJar $ docker-compose -f docker-compose-dev.yml up backend  or\n$ ./gradlew clean build shadowJar -i -x check $ docker-compose -f docker-compose-dev.yml run --rm -it backend bash $ java -jar dns-proxy-server-*-all.jar  "
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/latest/en/api/",
	"title": "API",
	"tags": [],
	"description": "",
	"content": " APIs  V1 Network API   "
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/latest/en/4-developing/generating-docs/",
	"title": "Generating the docs",
	"tags": [],
	"description": "",
	"content": " Introduction DPS uses Hugo and the theme-learn to generate static docs.\nRequirements  Hugo 0.55.4  Live Docs Preview Vanilla $ hugo server --source docs  Docker $ docker-compose -f docker-compose-dev.yml up docs  Generating Doc Statics To generate the HTML use the following\n$ ./builder.bash docs  "
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/latest/en/2-features/solving-host-machine-ip/",
	"title": "Solve host machine IP from anywhere",
	"tags": [],
	"description": "",
	"content": "Just use host.docker\n$ ping host.docker PING host.docker (172.21.0.1) 56(84) bytes of data. 64 bytes from 172.21.0.1 (172.21.0.1): icmp_seq=1 ttl=64 time=0.086 ms 64 bytes from 172.21.0.1 (172.21.0.1): icmp_seq=2 ttl=64 time=0.076 ms 64 bytes from 172.21.0.1 (172.21.0.1): icmp_seq=3 ttl=64 time=0.081 ms  You can customize this hostname by setting\nEnvironment variable\n$ docker run dns-proxy-server -e MG_HOST_MACHINE_HOSTNAME=$(cat /etc/hostname)  Command line option\n$ ./dns-proxy-server --host-machine-hostname $(cat /etc/hostname)  Json configuration\n{ \u0026quot;hostMachineHostname\u0026quot;: \u0026quot;host.docker\u0026quot; }  Notes:\nBe aware if you set the host machine hostname as the machine name then you will have to remove its name from /etc/hosts since OS try to resolve names from hosts file first then from DNS server\n"
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/latest/en/2-features/accessing-container-by-name/",
	"title": "Access container by its container name / service name",
	"tags": [],
	"description": "",
	"content": "It\u0026rsquo;s possible solve containers by their container or service name, consider the following sample, the container my-nginx can be solved by querying the hostname my-nginx.docker, the .docker domain is also configurable by the domain configuration json property.\n$ docker run --rm --name my-nginx nginx  $ nslookup my-nginx.docker Server:\t172.17.0.3 Address:\t172.17.0.3#53 Non-authoritative answer: Name:\tmy-nginx.docker Address: 10.0.2.3  You can enable this feature by\nActivating by command line\n./dns-proxy-server -register-container-names  Configuring at json config file\n... \u0026quot;registerContainerNames\u0026quot;: true ...  Using environment variable\nMG_REGISTER_CONTAINER_NAMES=1 ./dns-proxy-server  You can also customize the domain from docker to whatever you want by\nActivating by command line\n./dns-proxy-server --domain docker  Configuring at json config file\n... \u0026quot;domain\u0026quot;: \u0026quot;docker\u0026quot; ...  Using environment variable\nMG_DOMAIN=docker ./dns-proxy-server  "
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/latest/en/4-developing/releasing/",
	"title": "Release Process",
	"tags": [],
	"description": "",
	"content": " Feature Request - Phase 1  Create a pull request CI will be checked automatically Once CI is passing, the author @mageddo must approve the PR Merge the PR  Pre-Releasing New Version - Phase 2  Define the new version number Document the new version and changes at RELEASE-NOTES.md Generate the git tag with the steps below  Patch Version\n$ ./gradlew release  Major Version\n$ VERSION=3.18.0 \u0026amp;\u0026amp; ./gradlew release -Prelease.releaseVersion=${VERSION} -Prelease.newVersion=${VERSION}  Release Latest - Phase 3  Define a pre-release version which will be promoted to the latest by following the rules. Edit the github release setting latest flag Run the release latest workflow, if you don\u0026rsquo;t run the workflow it will auto run on the next day at 07:30 UTC  "
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/latest/en/versions/",
	"title": "Versions",
	"tags": [],
	"description": "",
	"content": " latest 3.24 3.24 3.23 3.22 3.21 3.20 3.19 3.18 3.17 3.16 3.15 3.14 3.13 3.12 3.11 3.9 3.8 3.7 3.6 3.5 3.4 3.3 3.2 3.1 3.0 2.19 2.18 2.15 2.14 2.13  "
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/latest/en/2-features/specify-from-which-network-solve-container/",
	"title": "Specify from which network solve container IP",
	"tags": [],
	"description": "",
	"content": "If your container have multiple networks then you can specify which network to use when solving IP by specifying dps.network label.\nCreating a container with two networks attached to\n$ docker network create --attachable network1 $ docker network create --attachable network2 $ docker run --name nginx1 --rm --label dps.network=network1 --hostname server1.acme.com --network network1 nginx $ docker network connect network2 nginx1  Getting networks masks\n$ docker network inspect -f \u0026quot;{{ .IPAM.Config }}\u0026quot; network1 [{172.31.0.0/16 172.31.0.1 map[]}] $ docker network inspect -f \u0026quot;{{ .IPAM.Config }}\u0026quot; network2 [{192.168.16.0/20 192.168.16.1 map[]}]  Solving container and checking that the solved IP will be respective to the configured network at dps.network label\n$ nslookup server1.acme.com Server:\t172.17.0.3 Address:\t172.17.0.3#53 Non-authoritative answer: Name:\tserver1.acme.com Address: 192.168.16.2  "
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/latest/en/2-features/dps-network-resolution/",
	"title": "DPS Docker Network",
	"tags": [],
	"description": "",
	"content": " Since: 2.15.0\nDPS can create its own network which is called dps and connect all running containers to that network this way all containers can comunicate to each other, when container A solve container B IP, which will be able to ping B cause they are on the same network (dps). Observes that you are also able to create your own network and make this job of connect the containers you want to be able to talk each other.\nActivating by command line\n./dns-proxy-server --dps-network-auto-connect  Configuring at json config file\n... \u0026quot;dpsNetworkAutoConnect\u0026quot;: true ...  Using environment variable\nMG_DPS_NETWORK_AUTO_CONNECT=1 ./dns-proxy-server   OBS: with this feature disabled or not, DPS gives priority to solve bridge networks over the others (if a bridge network were found for the container)\n Why it is necessary We can simulate the issue by the following example:\nYou have a container running on an overlay network (so you need to be running docker in a swarm mode), then it means the container can not be accessed by the host or by containers which are not in this same network\ndocker-compose.yml\nversion: '3.2' services: nginx-1: image: nginx container_name: nginx-1 hostname: nginx-1.app networks: - nginx-network networks: nginx-network: driver: overlay attachable: true  starting up the container and testing\n$ docker-compose up $ curl --connect-timeout 2 nginx-1.app curl: (7) Failed to connect to nginx-1.app port 80: Connection timed out  The solution for it can be use dps network or specify a bridge network on the docker-compose.yml\ndocker-compose.yml\nversion: '3.2' services: nginx-1: image: nginx container_name: nginx-1 hostname: nginx-1.app networks: - nginx-network - nginx-network-bridge networks: nginx-network: driver: overlay attachable: true nginx-network-bridge: driver: bridge  $ docker-compose down $ docker-compose up $ curl -I --connect-timeout 2 nginx-1.app HTTP/1.1 200 OK  "
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/latest/en/2-features/multiple-environments/",
	"title": "Multiple Environments",
	"tags": [],
	"description": "",
	"content": "As DPS 2.18 you can group your hostnames by environments, this is a very useful feature when you wanna solve the same hostname to different IPs depending of what you\u0026rsquo;re doing, e.g developing in your machine or testing the QA environment as the example below:\nLet\u0026rsquo;s say you\u0026rsquo;re developing at the acme.com so you wanna solve it to your local machine, then you can configure DPS local entries as the following\nWhen you are done with your work and deployed to the QA environment and wanna test it, let\u0026rsquo;s say your app is deployed at the QA machine addressed by the IP 192.168.0.50, so you can create a new env on DPS e.g. QA and create the acme.com A record pointing to the 192.168.0.50 address.\nThis way you can swap between local and qa environments in a fast and convenient approach\n"
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/latest/en/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/latest/en/5-tutorials/docker-reverse-proxy/",
	"title": "Configuring a Service Discovery solution on Docker using DNS Proxy Server and NGINX",
	"tags": [],
	"description": "",
	"content": " Requirements  DPS already configured, see the docs if you haven\u0026rsquo;t yet.  Tested on:  DPS 3.11 OS: Mac, Linux, Windows  Introducing You will see how to develop with docker containers solving them by hostnames from your host machine as the following picture shows:\nif you know about DPS you will figure out that\u0026rsquo;s a very basic DPS feature and you don\u0026rsquo;t need complex configurations to achieve that, except on MAC and Windows as docker runs its containers on a virtual machine so DPS default feature to solve containers names will work but the solved IPs are worthless because they aren\u0026rsquo;t accessible from the host.\nTo fix that we will configure an API Gateway, Service Discovery, Reverse Proxy solution combining DPS with Nginx, see final solution below:\nSource: excalidraw\nConfiguring The pratice is simpler than the theory, let\u0026rsquo;s get it working:\nConfiguring Nginx reverse proxy and two web apps for test\n$ git clone https://github.com/mageddo/dns-proxy-server.git $ cd examples/api-gateway_service-discovery_reverse-proxy $ docker-compose build --no-cache $ docker-compose up  docker-compose up created three containers, the first is a nginx reverse proxy which will listen to the host machine 80 port and two others are web apps which the reverse proxy will proxy to depending on the hostname queried.\nReverse Proxy will listen all .webapp hostnames and proxy to .container containers.\nSee docker-compose.yml for more details about each docker service.\nThe final step is to configure a wildcard to handle when something on the host queries for .webapp:\nTesting From the hostname Web app 1 is working:\n$ curl -i -X GET http://web-app.webapp HTTP/1.1 200 OK Server: nginx/1.23.3 Date: Thu, 16 Mar 2023 03:18:53 GMT Content-Type: text/html Content-Length: 37 Connection: keep-alive Last-Modified: Thu, 16 Mar 2023 02:35:50 GMT ETag: \u0026quot;64128086-25\u0026quot; Accept-Ranges: bytes \u0026lt;h1\u0026gt;Hello World from web-app!!!\u0026lt;/h1\u0026gt;  Web app 2 is also working:\n$ curl -i -X GET http://web-app-2.webapp HTTP/1.1 200 OK Server: nginx/1.23.3 Date: Thu, 16 Mar 2023 03:30:19 GMT Content-Type: text/html Content-Length: 615 Connection: keep-alive Last-Modified: Tue, 13 Dec 2022 15:53:53 GMT ETag: \u0026quot;6398a011-267\u0026quot; Accept-Ranges: bytes \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Welcome to nginx!\u0026lt;/title\u0026gt; ...  Apps can also access each other by its hostname No reverse proxy is necessary here, so you can connect a web-app to a database container by its hostname for example.\nweb-app-1 connecting to web-app-2\n$ docker-compose run web-app curl -I web-app-2.webapp.container HTTP/1.1 200 OK Server: nginx/1.23.3 Date: Thu, 16 Mar 2023 03:55:02 GMT Content-Type: text/html Content-Length: 615 Last-Modified: Tue, 13 Dec 2022 15:53:53 GMT Connection: keep-alive  That\u0026rsquo;s all, if you have any contribution or question feel free to open a pull request or an issue on the Github repo, thanks for reading.\n Service Discovery, API Gateway, Service Discovery, Reverse Proxy\n "
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/latest/en/credits/",
	"title": "Credits",
	"tags": [],
	"description": "",
	"content": " Contributors Thanks to them  for making Open Source Software a better place !\n.ghContributors{ display:flex; flex-flow: wrap; align-content: flex-start }\n.ghContributors \u0026gt; div{ width: 50% ; display: inline-flex; margin-bottom: 5px; } .ghContributors \u0026gt; div label{ padding-left: 4px ; } .ghContributors \u0026gt; div span{ font-size: x-small; padding-left: 4px ; }\n  @mageddo 843 commits \n @josielrocha 9 commits \n @mrubli 3 commits \n @addshore 3 commits \n @AJenbo 1 commits \n @dvarrazzo 1 commits \n @imartinezortiz 1 commits \n @SimJoSt 1 commits \n @ThisIsQasim 1 commits \n @dependabot[bot] 1 commits \n\n"
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/latest/en/2-features/docker-different-networks-solving/",
	"title": "Different Docker Networks Solving",
	"tags": [],
	"description": "",
	"content": "DPS can lead with docker containers with different networks, it will find the target container best matching IP, best matching means the IP which have the most chances of be accessible from the client, no distinction if the client is another container or not.\nYou can click here to see a pratical working sample.\nThe following table describles the possible scenarios involving docker container networks, some scenarios won\u0026rsquo;t work, you can consider enable DPS Docker Network feature so all contains will always be able to talk with each other.\n   DPS Container Network Client Container Network Target Container Network Result Description     any bridge network any bridge network any bridge network OK Everything works fine when all the networks are using bridge driver, no problem if the networks are different   Network x Network x Network x OK Even with restrictive networks (like overlay driver) the resolution will work, since all containers are connected to this same network.   Network a, Network b Network a Network b PARTIALLY OK Resolution is OK but Client Container can\u0026rsquo;t ping Target Container. The minimal requirement is that client must be on the same network which DPS so the client will able to query DPS, then client also need to be on the same network which the target container, so it will be able to ping after solve the hostname.   Network a Network b Network b NOK Client container won\u0026rsquo;t be able to talk with DPS    "
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/latest/en/",
	"title": "Getting Started",
	"tags": [],
	"description": "",
	"content": " Main features DPS is a lightweight end user (Developers, Server Administrators) DNS server tool which make it easy to develop in systems where one hostname can solve to different IPs based on the configured environment, so you can:\n Solve hostnames from local configuration database Solve hostnames from docker containers Solve hostnames from a list of configured remote DNS servers(as a proxy) if no answer of two above Solve hostnames using wildcards Graphic interface to Create/List/Update/Delete A/CNAME records Solve host machine IP using host.docker hostname  "
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/latest/en/2-features/local-entries/",
	"title": "Local Entries Solving (LocalDB)",
	"tags": [],
	"description": "",
	"content": "You can configure pre-defined A, AAAA, CNAME entries to solve Records, DPS will query them after docker containers and before remote servers. You can configure them by the JSON config file or using the GUI.\nJSON Configuration Example\n{ \u0026quot;activeEnv\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;envs\u0026quot; : [{ \u0026quot;name\u0026quot;: \u0026quot;\u0026quot;, // empty string is the default enviroment \u0026quot;hostnames\u0026quot;: [{ // all local hostnames entries \u0026quot;id\u0026quot;: 1, // (optional) used to control it will be automatically generated if not passed \u0026quot;type\u0026quot;: \u0026quot;A\u0026quot;, // Other options: CNAME, AAAA \u0026quot;hostname\u0026quot;: \u0026quot;github.com\u0026quot;, \u0026quot;ip\u0026quot;: \u0026quot;192.168.0.1\u0026quot;, \u0026quot;ttl\u0026quot;: 255 // how many seconds cache this entry }] }] }  "
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/latest/en/showcase/",
	"title": "Showcase",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://mageddo.github.io/dns-proxy-server/latest/en/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]